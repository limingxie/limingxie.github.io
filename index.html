<!DOCTYPE html>
<html lang="en-us">
<head prefix="og: http://ogp.me/ns#">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <meta property="og:title" content=" li_mingxie - Blog" />
  
  <meta name="theme-color" content="#hexcolor" />
 
  <meta property="og:site_name" content="li_mingxie - Blog" />
  <meta property="og:url" content="https://limingxie.github.io/" />
  
  
  <meta property="og:type" content="website" />
  

  <title>
     li_mingxie - Blog
  </title>

  <link rel="stylesheet" href="https://limingxie.github.io/css/bootstrap.min.css" />
  <link rel="stylesheet" href="https://limingxie.github.io/css/main.css" />
  <link rel="stylesheet" href="https://limingxie.github.io/css/font-awesome.min.css" />
  <link rel="stylesheet" href="https://limingxie.github.io/css/github.css" />
 
  <link rel="shortcut icon" href="https://limingxie.github.io/images/favicon.ico" />
  <link rel="apple-touch-icon" href="https://limingxie.github.io/images/apple-touch-icon.png" />
  
  <link href="https://limingxie.github.io/index.xml" rel="alternate" type="application/rss+xml" title="li_mingxie - Blog" />
  

  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1333035c981597c935706422cb31b76b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
    
</head>
<body>
    <header class="global-header"  style="background-image:url( /images/bg.jpg )">
    <section class="header-text">
      <h1><a href="https://limingxie.github.io/">li_mingxie - Blog</a></h1>
      
      <div class="sns-links hidden-print">
  
  <a href="mailto:li_mingxie@163.com">
    <i class="fa fa-envelope"></i>
  </a>
  
  
  
  
  
  
  
  
  
  
  
  
</div>

      
      
      <a href="https://limingxie.github.io/index.xml" class="btn-header btn-subscribe hidden-xs">
        <i class="fa fa-rss" aria-hidden="true"></i>
        &nbsp;Subscribe
      </a>
      
    </section>
  </header>
  <main class="container">

<div class="article-list">
  
  
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/do_change/">一个小小变化的威力</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-11-11T07:28:49&#43;08:00">
          Nov 11, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    今天是双11，本想来公司凑凑热闹&hellip;^^
结果主要问题都是在我的服务里，还把登录给整瘫了半个多小时&hellip;ㅠㅠ
高峰过去了，可以松口气了~ 抽个时间写写博文。
这次我想共享我们公司一个部门遇到的事情。
那天我正在为拆分服务的问题而苦恼着。
(本来是一个的服务拆分成4个服务，问题巨多&hellip;ㅠㅠ)
有位同事(韩国人)跟我说，看到了一些不太正常的请求。
希望我帮他和相关负责人沟通。(我是朝鲜族，有时候会帮他们沟通)。
在沟通的过程当中，我感觉到这是一个很有趣的问题。
◆ 为什么会有这么多的请求？ 先简单的说一下业务吧。
线上(天猫商城)出售一笔商品，线下的卖场会把这个单子抢过来，自行给购物者发货。
全国各地的卖场会积极的抢线上出售过的单子，因为每抢到一笔单子，他们就有提成赚。
所以比较勤奋的卖场人员只要店里没有顾客的话就会不停的刷单。
(不停的给服务器发Request请求，看看有没有可抢的单子。)
有些喜欢思考的人就会问，那不能做成推单吗？
这样就没有这种查询的压力了。为什么不难么做是有种种原因的这里不做解释了。
那问题是什么呢？其实就是请求量异常的的多。
在我们不怎么注意的情况下，Request请求量1个月内翻了6倍！
不可能吧？当时是9~10月份。又不是双11，又不是做了什么活动&hellip;
卖场数量没什么太多的变化，这请求数量怎么会上升的这么快？
◆ 原来是有人用脚本刷单啊？ 我们赶紧查看了一下日志，发现有几个卖场的请求比较异常。
1个卖场1天内请求量居然达到了10万次。
就是说1秒一次也是刷20个小时也只能刷7.2万次。
而且我们在前端做了限制是3秒才能刷一次。
这问题就简单了，肯定是这几个卖场是在用脚本刷单。
而且是有点IT基础的人获取后台api的url刷单。
◆ 好像不对？日志证明不了有人用脚本刷单 但是我们看了前一天的日志，傻眼了。
请求量最高的卖场不停的变。
这就不能证明有几个卖场人员是用脚本刷单了。
用脚本刷单的卖场，应该是每天都会刷单吧？ 而且请求量最高的卖场分布在全国各地区，
今天是这家卖场，明天又是另一家卖场&hellip;.ㅠㅠ
我们开始怀疑我们的程序有问题了。
是不是有bug在特定的情况下会不停的发请求?
开始争辩:
项目的负责人说我们的程序绝不会有这样的问题。
我们就反问你怎么证明你的程序是没问题？
◆ 虽然不知道怎么办，但是我们可以做一些改变 争论一番后，大家都累了。不知道怎么解决这件事情。
大家你看我，我看你~ 都等着别人出方案&hellip;^^;;
这怎么办啊？联系了卖场，卖场负责人说我们这里没有异常~ 也不承认自己用了什么脚本。
(这举动很傻，如果我是卖场人员，即使用了我也不会承认自己用了脚本刷单。)
这时候我们发现这个api没有做身份验证。我们提议要不要做身份验证？
(至于为什么不做身份验证，好不专业之类的评价我不做解释了~)
这是一个比较古老的api，而且过些日子会有新的api代替他的。
所以相关的负责人是不怎么希望动这套代码。
而且做身份验证是解决不了这个古怪的现象的。
最后我们决定加身份验证看看，当时大部分的人都认为做身份验证没什么用。
没事找事，这老代码改动后，万一报错怎么办？
虽然我们不知道有什么效果，或是给我们带来什么？
总比什么都不做强吧？
◆ 加了身份验证没什么效果啊？ 添加身份验证功能以后，早上我们紧急发布了新版本。
看了日志，我们失算了~ 没效果&hellip;ㅠㅠ
没有报我们想看的401验证失败的错误， 而且又是别的几家卖场刷单刷的特别厉害。
NND 这问题怎么解决啊？
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/do_change/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/work_sharing/share_001/">技术Leader需要哪些能力？</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-09-24T07:28:49&#43;08:00">
          Sep 24, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    身为一个高龄开发者(30岁以上应该都属于高领开发者吧？ 这世道&hellip;ㅠㅠ)，
我也一样(35岁&hellip;ㅠㅠ)，对以后的职业发展有很多苦恼。
我是幸运的，因为我们公司有一位高龄的技术牛人。
让我看到了一丝希望。原来做技术也可以做到这种程度。
(写了好几本书，开源代码社区的CodeReviewer，我问的问题没有一个回答不了的。)
前些天有幸和这位牛人做了一些工作上的交流，
如何做好技术Leader，让我感触特别的深刻。
以下是他给我的建议以及我自己的感触，想和大家一起分享。
快速的转换思维的能力 我们写代码的时候不喜欢被打扰，谁也不喜欢自己聚精会神的工作的时候有人过来打扰自己。
但是大部分的情况下，我们不是单打独斗。
身为技术Leader，我们就有义务去协助组员。
当我们有一定的能力以后，甚至需要协助几个小组或全公司的技术。
在这种情况下，如果拒绝被打扰，等于是不想做这个技术Leader。
我们需要学会`快速的进入角色`，进入时间越短越好。 一般情况下，别人做一些复杂的开发的时候需要5~10分钟去`从新进入状态`的话， 我们要在1分钟内，甚至30秒内要进入状态。 哪怕是自己的开发，或是其他人问题的解答。`必须快速的进入状态去解决问题。` A过来问，解答后我们用5分钟的时间调整状态做自己的事情，刚准备好B过来了。 等把B的问题看完后，再用5分钟的时间调节自己的状态，过了不到10分钟，C又过来问.... 等着晚上加班做自己的事情吧...^^||  所以快速的转换思维进入状态能力很重要，需要有意的去提高这个能力才行。
细分工作的能力 身为技术Leader现在准备好随时被打扰了吗？
随时被打扰，我们的工作就不做了吗？
所以我们还需要细分工作，分的颗粒度越小越好。
我一般喜欢这种编程方式。 觉得这是一个比较复杂的内容，'就直接写个空的方法。先返回null。' 走下一个逻辑。`先把这个流程或是这个逻辑走完。` 之后再写刚才觉得复杂的那个方法。 这么写话，每个函数所实现的内容不多，中间被打断也是很容易从新进入状态。 也可以先让问问题的人等几分钟，先把这个逻辑写完后，再一起讨论他的问题。  所以提高细分工作的能力会让不断的打扰中，保持工作的节奏和状态。
不断的摸索提高自己的开发效率的方法 不断的被打扰，不断的开会。
让技术Leader们很难有充分的时间去编程。
那技术Leader就不需要写代码吗？
或是写很少一部分的代码就可以了吗？
其实不是，为了保持自己对技术感觉，我们还需要不断的写代码。
那怎么办？
这会要求我们别人写2个小时的内容，我么是要在1小时甚至半小时内写完。
需要不断的去找合适自己，提高自己效率的方法。 举例子，合理的运用快捷键。command + ~ , command + -&gt;... git的gcb, ga, gcmsg, ggpull, ggpush, glum, glog ... vsCode的多行修改， opton + 方向键，control + -&gt; ... 合理的分配屏幕的结构，左边数据库，中间代码窗，下面zsh窗，右边postman等等... 我们需要不断思考，寻找对自己合适的开发方式。 还有最重要的一项'提高整体的技术能力以及思维能力。'  不断的摸索提高自己的开发效率的方法，学会短时间内出满意的产出物。
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/work_sharing/share_001/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/linux_command/">linux 常用命令整理(一)</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-09-02T07:28:49&#43;08:00">
          Sep 2, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    这么晚了才认识了linux系统。感觉越来越喜欢linux系统了。
废话少说，这几天自己做的笔记，炫耀一下&hellip;.^^
方便以后用的时候查找。
 命令行 备注   pwd: 改变目录 cd..   ls: 列出目录内容 ls -l = ll  ls -l t 时间排序 S 大小排序 -d 目录  ls -lt --reverse  ls -F 所有文件  Ls -i 查看所有节点inodemv    file: 确定文件类型   less: 查看文件内容   cp: 复制文件和目录 -a 复制所有文件一起权限 -r 递归复制 -u 复制没有或更新的内容  cp file1 file2 dir1 复制文件file1和file2 到dir1   mv: 移动或重命名文件夹和目录 -i 操作需要做确认 -u -v 显示信息  mv file1 file2 file1移动到file2 或重命名file2  mv file1 file2 dir1 将file1,file2 移动到dir1 前提是dir1必须存在   mkdir: 创建目录   rm: 移除文件盒目录 危险的命令，先用ls 看看是不是你要删除的文件，在换成rm执行。  -i 需要确认删除 -r 递归删除 -f --force 忽略提示全部删除 -v 查看信息  rm -rf file1 dir1 删除 file1和dir2 并且不提示执行删除   ln: 创建硬链接和符号链接  in file link 创建硬链接  in -s item link 创建符号链接，这里item可以是目录   通配符 g* g开头的任意文件  b*.
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/linux_command/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/solid/">solid原则简单笔记</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-09-01T07:28:49&#43;08:00">
          Sep 1, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    这些天因为工作上的需求，一套代码部署到不同的环境里。
虽然说是一样的业务，但是在不同的环境里难免会有一些少许不同的业务。
刚开始的时候觉得没什么问题，分了几个分支。
但是后来感觉越来越不对劲了，不同的环境分不同的分支，以为是很简单的事情。
时间长了，分支之间的差异也越来越大，感觉应该分不同的仓库。
这分了仓库问题又来了，改了Bug需要再不同的仓库里重复的修改代码，审查代码，合并代码，测试&hellip;
把我忙的不亦乐乎。
这让我怀疑，是不是代码结构本身有问题？
虽然现在用的Go语言不是面向对象编程语言，
但是我觉得经典的面向对象编程思想应该能对我有帮助。
查到了一个很有趣的原则：solid原则。
当做自己的笔记简单的整理了一下solid原则。
SRP	The Single Responsibility Principle	单一责任原则 OCP	The Open Closed Principle	开放封闭原则 LSP	The Liskov Substitution Principle	里氏替换原则 ISP	The Interface Segregation Principle	接口分离原则 DIP	The Dependency Inversion Principle	依赖倒置原则  ◆ 单一责任原则(The Single Responsibility Principle)
一个类只完成它应该完成的职责。  这一原则其实项目刚开始的时候很容易遵守。
但是项目久了后，你会发现你的项目越来越变味儿。
需要不断的重构中，维持单一责任原则。
◆ 开放封闭原则(The Open Closed Principle)
软件实体(类,模块,函数等等)应当对扩展开放，对修改闭合。  好难好难。
尤其是api的版本不断的升级，老版本的api又不能弃用的时候，
而且结构在不断的变化的时候&hellip;ㅠㅠ
◆ 里氏替换原则(The Liskov Substitution Principle)
只有在确定是 is-a 的关系时才能使用继承。  这一原则我刚开始的时候还真不理解。其实很简单。
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/solid/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/git_cherry_pick/">git命令 cherry-pick 的使用简介</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-07-30T07:28:49&#43;08:00">
          Jul 30, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    上一篇文章介绍了merge和rebase的用法以及原理。
git命令merge和rebase的简单应用
这里简单的介绍一下 cherry-pick 的用法。
什么时候会用到 cherry-pick 命令？
代码分几个大分支，各自有不同的功能在开发，这时候我们就有这样的需求。
只合并某个分支上的某次修改commit到指定的分支上。
这时候就可以使用cherry-pick命令来操作。
$ git cherry-pick commit_id //想合并的commit_id  图片备用地址
如果是图1这样使用cherry-pick命令的话，
会有 a1, a2, a3 的合并项，在代码中需要删除 a1, a2 再次提交解决冲突才行。
喜欢找茬的人会这么问：这么一来和merge有什么区别吗？
merge的话也不是把 a1, a2, a3 的代码合并过来吗？
merge合并后把 a1, a2 删掉的话跟cherry-pick有什么区别？
区别在于日志。
$ git cherry-pick fd4e09c(a3的 commit_id) error: could not apply fd4e09c... add a3 hint: after resolving the conflicts, mark the corrected paths hint: with 'git add &lt;paths&gt;' or 'git rm &lt;paths&gt;' hint: and commit the result with 'git commit' //.
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/git_cherry_pick/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/git_merge_rebase/">git命令merge和rebase的简单应用</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-07-29T07:28:49&#43;08:00">
          Jul 29, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    因为工作的需求，项目分了几个大分支管理了。
不同的环境需要的功能也不一样，在不同的分支里修改。
虽然我不太喜欢这种做法。但是借此机会对merge和rebase, cherry-pick命令研究了一些。 (我比较倾向，有一个主分支，发布在不同的环境是应该由不同的配置和适当的继承来实现。
如果这么做实在太麻烦的话，应该另分出一个仓库repository管理。)
以下是我简单整理的内容。
◆ merge merge就是合并不同分支的代码。
先举个简单的使用场景例子。
从master分支分出一个dev分支开发。
期间我们master分支有 m1,m2,m3 的提交记录。
dev分支有 d1,d2 的提交记录。
2个分支需要合并代码。
$ git merge dev --在master分支把dev分支的代码合并过来。  把2支分支合并，有冲突，解决冲突后需要提交一次合并代码记录。
(为了简单，下图是没有冲突时的场景。)
图片备用地址
◆ rebase rebase其实就是重置代码历史，手动的修改提交记录和代码。
一般项目当中有两种用法。
1. 合并记录
这是一般开发者处理完Issue后，给主分支发出合并请求了。
但是CodeReview的时候发现有不合适的代码，或是有个小Bug需要修改。
修改后又出现一个提交记录，1个Issue有2个提交记录，看着不舒服。
这时候用以下方式处理。
$ git rebase -i HEAD~2 --2代表要修改最近2个记录  图片备用地址
2. 调整顺序
git merge语法是按照时间顺序合并代码的。
图1所示merge是时间的顺序来合并代码的。
master: m1 -&gt; m2 -&gt; m3 dev: d1 -&gt; d2 ==&gt; -- 合并的代码记录是按照时间的排序 master: m1 -&gt; d1 -&gt; m2 -&gt; d2 -&gt; m3  当开发到 m2 的时候我们发布了一个版本，合并了d1,d2后发布出现问题了。
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/git_merge_rebase/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/redis/">Redis简单应用</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-07-01T07:28:49&#43;08:00">
          Jul 1, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    这些天因为项目性能上的问题，采用了Redis缓存。
做了一些简单的笔记。
◆ Redis
Redis(REmote DIctionary Server)是一个key-value存储系统。
它支持存储的value类型很多，包括string、list、set、hash等等&hellip;
我最喜欢用 key-json字符。
◆ 应用
用的也简单，代码逻辑中读取相应的信息的时候先去Redis读取，
没有数据，再去数据库(mysql)读取。保存到Redis后，返回结果集。
因为Redis的数据是保存在内存里的(分保存的方式，暂且可以理解成保存在内存)，
所以查询速度会很快。
◆ 缺点
也很容易看到他的缺点，
1. 一致性问题。 为了高效查询性能，付出的代价是数据的一致性。
2. 而且内存的资源是有限的，所以要控制数据量的大小。
◆ 如何去解决的？
如果没有太高的一致性需求的话，
可以直接设置比较短的缓存时间来解决一致性的问题。
比方说缓存时间设置为5分钟，5分钟后数据无效，那再次去数据库查询。
要么做定时任务，每隔一段时间做数据同步。
如果数据一致性需求很高，
建议每次数据有变动代码里需要添加删除Redis数据的逻辑。
(万一这数据的Mapping关系比较复杂的话，光是删掉这些有关系的数据也会让你哭死&hellip;)
只要删掉了，下次查询会从新去数据库查询数据。

我这只是简单应用，没什么深度，哈~ 下面简单的整理了一下语法 1. 安装Redis (我比较喜欢下docker镜像安装，如果不想这么做可以搜一下&hellip;^^)
$ docker run --name test-redis -p 33201:6379 -d redis:latest   &mdash;name 后面的是docker容器名 -p 32xxx:6379 这里需要注意 32xxx 是你链接redis的时候的Port。 -d redis:latest 是你的镜像标签和版本  2. 在shell中访问redis
$ redis-cli -h 127.0.0.1 -p 33201 //链接redis 127.
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/redis/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/blockchain_2/">区块链blockchain基础入门(二)</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-06-22T07:28:49&#43;08:00">
          Jun 22, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    上一篇文章简单的介绍了一下区块链blockchain到底是什么。
区块链blockchain零基础入门(一)
接下来继续简单的介绍一下区块链blockchain的结构。
◆ 区块Block + 链Chain 区块链blockchain是由一个个区块block组成，每次交易的数据是写入到一个区块block中。
每个区块是由区块头Heather和去块体Body组成。
区块头Heather: 包含着生成时间，区块体Body的地址(Hash值)，以及上一个区块block的地址(Hash值)。 区块体Body: 详细的数据。  下图是简单的结构
图片备用地址 实际的Header的结构是这样的，不是IT行业的话可以略过下图。
图片备用地址 如上图所示，每个区块Block都保存前一个区块Block的地址(Hash值)。
这样我们就可以把每个区块block连接到上一个区块Block，组成很长的链chain。
这就是区块链blockchain名字的由来。
◆ 节点node 区块链blockchain中的数据是分布式存储。
这些数据会分布在不同的地方存储，存储数据的每一个点我们叫它为节点node。
(仅仅是在区块链blockchain中是可以这么理解)。
以比特币为例(比特币是第一个成功的区块链blockchain技术)。
比特币网络是由很多个节点node组成，而且每个节点node都保存所有的交易数据。
(这会导致很多的重复数据，我感觉这是一种浪费。哈~ )  打个比方，每个节点node都拥有同样的账本。
当某一个节点node增加新的交易数据(新的区块block)。
它会把这份交易数据(新的区块block)分发给各各节点node，
其他节点node收到账本的新一页(新的区块block)后，
把这份交易数据(新的区块block)放在自己账本(整个交易数据)的最后一页。
这样确保所有的节点node的账本是一致的。==&gt; (分布式存储)
图片备用地址 ◆ 挖矿mining 那万一2个以上的节点node同时创建新的区块block岂不是乱了吗？
这里牵扯到区块认证。比特币是大约10分钟一次创建新的区块block。
在这10分钟内的交易数据是以工作量证明(PoW)Proof-Of-Work方式，获得新建区块block权利。
什么意思？不太明白？
简单的说想要在区块链blockchain中添加新的区块block的话，
你需要要获得创建新区块Block的权利。
怎么获取添加新建区块block的权利呢？ 算一道题。 什么样的题？ 可以理解成一个猜数字游戏。1到10000中有一个数据是正确的让你去猜。 怎么办？没办法，只能暴力破解。 是不是5000？ 不是! 是不是5301？ 不是! 是不是xxx ？ 不是！ 是不是xxx ？。。。  这题猜中的偶然性很高，也有运气的成分。
但是如果你的服务器性能好的话，猜的次数越多，猜对的可能性也变得高。
猜对了，获得权利。你可以创建新的区块block，分发到网络。
大声告诉大家: “这道题我猜对了，我已经新建了一个区块block了，你们不用再算了。”
然后把自己建好的区块block分发给其他的节点node。
难度系数difficulty
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/blockchain_2/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/blockchain_introduction/">区块链blockchain零基础入门(一)</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-06-22T07:28:49&#43;08:00">
          Jun 22, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    区块链blockchain这几年比较火爆的词。
不是计算机行业的人如何去理解这么技术呢？
我简单的整理了一下，适合完全没有基础的人去看&hellip;^^
区块链blockchain到底是什么？
是一个软件吗？是一个服务吗？ 或是一个网站？
其实用一句话来说他是去中心化，分布式存储数据的技术方案。
还是不明白吗？
如果第一次接触这个概念，不明白是正常，明白了才奇怪呢&hellip;^^
我们先模拟一下A在tao宝里买B的衣服。
1. A ===下订单，付款===&gt; tao宝 2. B ===查看订单===&gt; tao宝 3. B ===发货===&gt; A 4. A 收到物品 5. A ===收货确认===&gt; tao宝 6. tao宝 ===扣除手续费，转账===&gt; B  这个过程当中，tao宝起到了一个中介的作用。
所有的信息通讯是通过它来完成的，中间还赚取手续费。
这里有2个问题需要思考。
1. tao宝把这笔交易记录删了，A如何证明自己从B那里买了衣服(假设衣服是次品想退货)？ 2. 能不能A直接给B付款，B直接给A发货？ 这样是不是省了手续费？  如果没有这个tao宝当中介会怎么样呢？ 问题就来了
1. 没有了中介，A给B付款后，B死赖账怎么办？ 2. 这交易记录存在哪里？  ◆ 那如何做到去中心化，又保障安全呢？
其实很简单, A观察到旁边有C,D,E。
A向大家喊：
A给B付款了，大家都听到了吗？  C,D,E是听到了， 但是出了问题人家会挺身而出给你作证吗？
于是A会这么喊：
A给B付款了，`谁帮我记录一下，我会给辛苦费的`。出问题麻烦您帮我作证。  D听到了这句话后，赶紧做记录。
然后把做好记录的账本给每个人都发一份。
这样D的任务就完成了，可以获得辛苦费了。
这样A和B没有通过tao宝，安全的完成了这笔交易了。 ==&gt; 去中心化
而且D做完记录后，把那些账本给每个人都分发了一份。 ==&gt; 分布式存储
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/blockchain_introduction/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/encrpytion_key/">公钥，私钥，数字签名，数字证书的相互关系</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-06-07T07:28:49&#43;08:00">
          Jun 7, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    我们经常听到数字证书，数字签名这些词。
这些证书，签名到底是什么？
他们又起到什么样的作用？ 其原理是什么？
了解这些我们需要先了解加密方式，以及什么是公钥？什么是私钥？
1. 加密方式 先解释一下2种常用的加密方式。
◆ 对称加密
加密的传统方法是对称加密。发出讯息者用一把钥匙对讯息加密。
接收讯息者需用这把钥匙将加密了的讯息解密。
这把钥匙必须以一种其他人没有机会得到它的方式给予接收讯息者。
如果其他人得到了这把钥匙，这种加密方式就没用了。
◆ 非对称加密算法
非对称加密算法需要两个密钥：公开密钥(publickey)和私有密钥(privatekey)
公开密钥与私有密钥是一对，可以相互加密和解密。
如果用公钥对数据进行加密，只有用对应的密钥才能解密。
如果用密钥对数据进行加密，那么只有用对应的公钥才能解密。
因为非对称加密算法安全性比较高，所以下面的数字签名，数字证书都是用了非对称加密算法。

2. 数字签名digital signature 在现实生活中，签名是为了表示这是签名者写的。计算机中，数字签名也是相同的含义。
举一个例子如果A，B两台计算机相互通讯：
A计算机传输给B计算机信息的时候，A计算机会在消息的最后写上去自己的签名，以代表这些信息是A计算机的。 B计算机接到消息后，先看签名是不是A计算机判断不是别人冒充A计算机发送不安全或是无效的信息(有效性)。 除此之外，数字签名还能证明消息传输过程中没有被篡改(完整性)。
◆ 原理
简单的说的话其实就是：
A计算机给B计算机传输信息的时候，
A计算机在信息后面加自己的签名(字符串)，用自己的私钥(privatekey)加密。
B计算机接到数据后，用A计算机的公钥(publickey)解密，确认来源是不是A计算机。
这样确保了完整性，而且A计算机也不可抵赖
(因为用A计算机公钥解密的信息只能是A计算机的私钥加密的信息)

3. 数字证书 先预想一个场景，如果有10台计算机，10台计算机需要记住相互之间的公钥(publickey)，
那有100台计算机，1000台呢？ 他们之间都需要记住相互的公钥吗？
答案肯定是不能，那如何解决这些问题呢？
其实很简单，有个第三方中介机构。记住了这些1000台的公钥相对应的资料。
这种机构称为认证机构(Certification Authority， CA)。
CA开一个证明这是计算机A的信息，发给B计算机。
B计算机通过CA的证明，可以确认这是A计算机的信息。
◆ 如何生成证书？
A计算机将自己的【公钥A】给CA
CA用自己的【私钥CA】给【公钥A】加密，生成【数字签名A】
CA把【公钥A】，【数字签名A】，附加一些【A计算机的信息】整合在一起，生成证书，发给A计算机。
◆ 如何验证证书？
A计算机发信息给B计算机的时候，会附加【数字签名A】
B计算机通过CA的公钥解密【数字签名A】，既可以确认这是A计算机发的信息。
(其实详细原理不是这样，是解证书得到哈希值，通过算法比较这个哈希值的。)

总结 两台计算机相互通讯的时候，为了确保有效性和完整性。需要签名证明是自己(数字签名)。
这签名不能随便公开，所以需要加密。
加密的时候使用的是非对称加密算法。(公钥，私钥)
相互通讯的计算机多了后，需要一个中介公司来证明这个签名是合法的(数字证书)。
这中介机构叫(Certification Authority， CA)。
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/encrpytion_key/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
</div>
<nav class="pagination" role="navigation">

  <hr />


  <span class="page-number">Page 1 of 2</span>

<a class="older-posts" href="/page/2/">Older Posts <span aria-hidden="true">&raquo;</span></a>

</nav>

  </main>
  <footer class="container global-footer">
    <div class="copyright-note pull-left">
      limingxie - blog
    </div>
    <div class="sns-links hidden-print">
  
  <a href="mailto:li_mingxie@163.com">
    <i class="fa fa-envelope"></i>
  </a>
  
  
  
  
  
  
  
  
  
  
  
  
</div>

  </footer>

  <script src="https://limingxie.github.io/js/highlight.pack.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
  
  
</body>
</html>



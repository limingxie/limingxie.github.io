<!DOCTYPE html>
<html lang="en-us">
<head prefix="og: http://ogp.me/ns#">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <meta property="og:title" content=" li_mingxie - Blog" />
  
  <meta name="theme-color" content="#hexcolor" />
 
  <meta property="og:site_name" content="li_mingxie - Blog" />
  <meta property="og:url" content="https://limingxie.github.io/" />
  
  
  <meta property="og:type" content="website" />
  

  <title>
     li_mingxie - Blog
  </title>

  <link rel="stylesheet" href="https://limingxie.github.io/css/bootstrap.min.css" />
  <link rel="stylesheet" href="https://limingxie.github.io/css/main.css" />
  <link rel="stylesheet" href="https://limingxie.github.io/css/font-awesome.min.css" />
  <link rel="stylesheet" href="https://limingxie.github.io/css/github.css" />
 
  <link rel="shortcut icon" href="https://limingxie.github.io/images/favicon.ico" />
  <link rel="apple-touch-icon" href="https://limingxie.github.io/images/apple-touch-icon.png" />
  
  <link href="https://limingxie.github.io/index.xml" rel="alternate" type="application/rss+xml" title="li_mingxie - Blog" />
  

  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1333035c981597c935706422cb31b76b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
    
</head>
<body>
    <header class="global-header"  style="background-image:url( /images/bg.jpg )">
    <section class="header-text">
      <h1><a href="https://limingxie.github.io/">li_mingxie - Blog</a></h1>
      
      <div class="sns-links hidden-print">
  
  <a href="mailto:li_mingxie@163.com">
    <i class="fa fa-envelope"></i>
  </a>
  
  
  
  
  
  
  
  
  
  
  
  
</div>

      
      
      <a href="https://limingxie.github.io/index.xml" class="btn-header btn-subscribe hidden-xs">
        <i class="fa fa-rss" aria-hidden="true"></i>
        &nbsp;Subscribe
      </a>
      
    </section>
  </header>
  <main class="container">

<div class="article-list">
  
  
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/java/reflect/">【java笔记】反射的简单应用</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2020-07-30T23:28:49&#43;08:00">
          Jul 30, 2020
        </time>
      </div>
    </div>
  </header>
  <div>
    今天在代码中看到了invoke方法，了解到原来是使用了反射的机制。
以前没怎么用过这种方式，所以简单的了解一下。
具体内容是简单的写了一套代码。
声明Animal类
import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; class Animal { public Animal() { } public Animal(String name, int age) { this.name = name; this.age = age; } private int age; public String name; public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; }  普通的方法和使用反射
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/java/reflect/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/java/this_super/">【java笔记】this和super简介</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2020-07-26T12:28:49&#43;08:00">
          Jul 26, 2020
        </time>
      </div>
    </div>
  </header>
  <div>
    本来是确认构造函数的运行方式的。
结果看到继承以及super关键字了&hellip;^^;;
都说this是类似于指自己的一个指针，super是更像一个关键字。
可能我的了解不是那么深入，觉得this就是指自己super就是指父类。其余没感觉到什么特别。
而且感觉前期了解这些就可以了，后面对Java有更深层次的了解后继续在研究~
下面是我简单的试一试，做个记录&hellip;^^
 1.this指向自己。
2.super指向父类。
3.多层继承时，super指向离自己最近的上一层父类。
4.不能同时继承类和接口，也不能同时继承抽象类和接口。
5.构造函数中使用this或super时，必须写在第一行。而且不能同时使用。
 我先创建了以下文件。
图片备用地址
先看看每个文件的代码
【Animal】一个普通的类和函数。
package supertest.animal; public class Animal { // 姓名属性，和子类的值不一样 protected String name = &quot;animalName&quot;; // 无参构造函数 public Animal() { System.out.println(&quot;Animal: There are no parameters&quot;); } // 有参构造函数 public Animal(String str) { System.out.println(&quot;parameters:&quot; + str); } // 父类的函数，子类会重写这个函数 public void run(String str) { System.out.println(str+ &quot;:&quot; + Animal.class); } }  【Horse】子类继承了Animal父类
package supertest.MammalInt; import supertest.animal.Animal; public class Horse extends Animal { // 姓名属性，和父类的值不一样 protected String name = &quot;horseName&quot;; // 无参构造函数 public Horse() { // 这里执行父类有参的构造函数 super(&quot;super has parameters&quot;); System.
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/java/this_super/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/java/abstract_test/">【java笔记】类, 抽象类, 接口的简单实验</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2020-07-26T07:28:49&#43;08:00">
          Jul 26, 2020
        </time>
      </div>
    </div>
  </header>
  <div>
    要接触，抽象，继承，多态，封装的java了。
为了加深理解自己做了一个简单的实验。
 1.类只能继承一个。
2.抽象类也只能继承一个。
3.接口可以继承多个。
4.不能同时继承类和接口，也不能同时继承抽象类和接口。
 我先创建了以下文件。 图片备用地址
先看看每个文件的代码
【AnimalAbstract】抽象类里添加了2个函数，其中一个是抽象函数。
package animals.animal; public abstract class AnimalAbstract { public void eat(String name){ System.out.println(&quot;eat:&quot; + AnimalAbstract.class + &quot; | name:&quot; + name); }; public abstract void sleep(String name); }  【AnimalClass】一个普通的类和函数。
package animals.animal; public class AnimalClass { public void smile(String name){ System.out.println(&quot;smile:&quot; + AnimalAbstract.class + &quot; | name:&quot; + name); }; }  【AnimalClass】两个不同的接口。
package animals.animal; public interface AnimalInterfaceJump { public void jump (String name); }  package animals.
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/java/abstract_test/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/java/serialization/">【java笔记】序列化和反序列化</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2020-07-02T07:28:49&#43;08:00">
          Jul 2, 2020
        </time>
      </div>
    </div>
  </header>
  <div>
    当做笔记简单了记录了一下。
1. 序列化和反序列化是什么？ 序列化(serializable):
把对象转化为可传输的字节序列过程称为序列化。  反序列化(deserialization):
把字节序列还原为对象的过程称为反序列化。  我觉得网上的这个比喻做的很恰当
 如果我们要把一栋房子从一个地方运输到另一个地方去，
序列化就是我把房子拆成一个个的砖块放到车子里，
然后留下一张房子原来结构的图纸，
反序列化就是我们把房子运输到了目的地以后，
根据图纸把一块块砖头还原成房子原来面目的过程。
 2. 什么时候会用到序列化？ 需要进行跨平台存储和网络传输的数据，都需要进行序列化。
对象的序列化主要有两种用途： 1） 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中； 2） 在网络上传送对象的字节序列。  3. 序列化版本 在序列化过程中，可以使用序列化对象中的serialVersionUID字段做版本控制。
一个对象数据，在反序列化过程中，序列化串中的serialVersionUID与当前对象值不同，反序列化会失败。
4. java实现序列化 java 实现序列化有两种方式。
1.实现Serializable 接口。 2.实现Externalizable 接口(它是Serializable接口的子类)  下面是用Serializable接口实现的简单例子:
import java.io.Serializable; public class Person implements Serializable{ // 如果不指定，JDK工具会自动生成对应的版本号， // 序列化和反序列化的版本号不一样，则反序列化会失败。 private final static long serialVersionUID = 123456789L; // 年龄 private int age; // 名字 private String name ; // 体重，Transient 属性不会被序列化 private transient int weight; public int getAge() { return age; } public void setAge(int age) { this.
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/java/serialization/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/k8s/k8s/">【k8s】kubernetes基本的概念</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2020-07-01T07:28:49&#43;08:00">
          Jul 1, 2020
        </time>
      </div>
    </div>
  </header>
  <div>
    最近抽时间了解Kubernetes。那些网上和官方的材料都讲得很深，很细。
我平时也用不上这些技术，不需要知道的这么深这么细，
花这么多少时间去了解，过几天没怎么用还会忘记的&hellip;ㅠㅠ
其实我想知道的是其大致的结构。
下面我是以笔记的形式见得整理了其结构。希望对刚刚接触的人的了解有所帮助。
1.基本概念 ◆ Kubernetes 是什么？
引用官方的解释：
 Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。
Kubernetes 拥有一个庞大且快速增长的生态系统。Kubernetes 的服务、支持和工具广泛可用。
 以我的理解：
Kubernetes(简称k8s)是一个可以操作容器和自动化部署的开源平台。
还不理解？ 没关系~
简单的说手动管理docker container太累，用Kubernetes管理吧~
一个服务器可以有多个docker container，多个服务器形成一个集群。
下面简单的介绍一下Kubernetes集群的结构。
2.Kubernetes集群结构 备用图片
图片来源于:https://kubernetes.io/docs/concepts/overview/components/
备用图片 图片来源于:http://omerio.com/2015/12/18/learn-the-kubernetes-key-concepts-in-10-minutes/
其他结构图： 备用图片1 备用图片2
简单的说：
每个Kubernetes集群都有他自己的master节点。
这里包含着kube-apiserver，kube-controller-manager，kube-scheduler，etcd。
看图和名字可以大致的猜到:
`kube-apiserver`是通讯枢纽。 `kube-controller-manager`是控制器。 `kube-scheduler`是调度器。 `etcd`是键值数据库。  普通的节点包含着kubelet, kube-proxy。
`kubelet`跟master节点通讯。 `kube-proxy`是网络代理。  下面具体的介绍一下比较重要的组件。
3.Kubernetes组件 ◆ Kubernetes Master
每个k8s集群里至少需要一个Master节点来负责整个集群的管理和控制，
所有控制命令都是发给它，它来负责具体的调度和执行。
master节点包含三个进程和一个键值数据库etcd。
三个进程都运行在集群中的某个节点上，主控组件通常这个节点被称为 master 节点。
这些进程包括：kube-apiserver、kube-controller-manager 和 kube-scheduler。
kube-apiserver:
集群内各个功能模块之间数据交互和通信的中心枢纽。 所有从集群到master的通信路径都终止于apiserver。  kube-controller-manager:
通过apiserver监控集群的公共状态，并致力于将当前状态转变为期望的状态。  kube-scheduler:
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/k8s/k8s/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/algorithm/recursive/">递归(recursive)</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2019-08-03T07:28:49&#43;08:00">
          Aug 3, 2019
        </time>
      </div>
    </div>
  </header>
  <div>
    最近在研究算法&hellip;^^ 算法中最基本的是排序。
排序当中最常见的是快速排序(Quick Sort)。
理解快速排序的代码，那就离不开递归了。
递归以前听过，但是真正去了解和研究是最近为了对算法的了解。
 递归感觉很绕？
 但是理解其原理的话还是可以接受的，甚至有时候会喜欢这种方式。
 递归不像传说中的那么麻烦。弄清楚
基线条件（base case）和 递归条件（recursive case）
 绝大多数的递归都是这种结构
function(parameter){ if 基线条件（base case）{ //离开递归的条件，这条件如果不明确，或是满足不了。很容易进入死循环。 return } XXXX...XXXX //处理业务逻辑 if 递归条件（recursive case）{ //进入递归的条件 function(parameter) } }  来看看一个简单的例子吧。详细内容可以看这里
https://pintia.cn/problem-sets/994805260223102976/problems/994805325918486528
卡拉兹(Callatz)猜想： 对任何一个正整数 n，如果它是偶数，那么把它砍掉一半； 如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。 我们假设 n &lt; 1000 输入样例： 3 输出样例： 5  一般情况下我们是直接用while或for循环处理。
#include &lt;stdio.h&gt; int main() { int step = 0; //记录步数 int n = 0; scanf(&quot;%d&quot;, &amp;n); while (n !
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/algorithm/recursive/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/algorithm/sort/">算法(排序)</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2019-07-09T07:28:49&#43;08:00">
          Jul 9, 2019
        </time>
      </div>
    </div>
  </header>
  <div>
    感觉现在越来越重视算法了。
因为我不是计算机专业的，所以对这些算法没怎么注意过。
这么高领的程序员居然才接触到这些算法，真是惭愧啊&hellip;^^;;
以下代码都是用golang写的，算是给自己看的笔记~
(1) 冒泡排序(Bubble Sort) (2) 选择排序(Selection Sort) (3) 插入排序(Insertion Sort) (4) 希尔排序(Shell Sort) (5) 归并排序(Merge Sort) (6) 快速排序(Quick Sort) (7) 基数排序(Radix Sort) (8) 堆排序(Heap Sort)   ◆ 冒泡排序(Bubble Sort)
图片备用地址
//泡沫排序 func BubbleSort() { data := []int{8, 100, 99, 50, 22, 15, 16, 2, 99, 1000, 999, 1} for i := 0; i &lt; len(data); i++ { for j := 0; j &lt; len(data)-i; j++ { if data[j] &gt; data[j+1] { v := data[j] data[j] = data[j+1] data[j+1] = v } } } fmt.
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/algorithm/sort/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/solid_1/">设计原则那些事儿</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2019-06-06T07:28:49&#43;08:00">
          Jun 6, 2019
        </time>
      </div>
    </div>
  </header>
  <div>
    代码架构的设计原则中最普遍的是solid原则。
SRP	Single Responsibility Principle	单一责任原则 OCP	Open Closed Principle	开放封闭原则 LSP	Liskov Substitution Principle	里氏替换原则 ISP	Interface Segregation Principle	接口分离原则 DIP	Dependency Inversion Principle	依赖反转原则   ◆ SRP:单一责任原则(Single Responsibility Principle)
一个类只完成它应该完成的职责。  任何一个软件模块都应该只对某一类行为者负责。 它的作用就是告诉我们在哪里划清边界。
◆ OCP:开放封闭原则(Open Closed Principle)
软件实体(类,模块,函数等等)应当对扩展开放，对修改闭合。  这其实就是要关注，增加新的功能的时候能不能不修改以前旧代码？
增加新功能，需要大改旧代码，说明没做好开放封闭原则。
◆ LSP:里氏替换原则(Liskov Substitution Principle)
模块之间应能自由替换。  其实就是替换别的模块的时候不应该影响别的模块，导致发生修改事项。
◆ ISP:接口分离原则(Interface Segregation Principle)
如果一个接口包含了过多的方法，应该通过分离接口将其拆分。  如果依赖和自己没有关系或不需要的东西，需要应该把他拆分，只依赖和自己有关系的不分。
◆ DIP:依赖反转原则(Dependency Inversion Principle)
上层(抽象)不应该依赖于下层(实体)，下层(实体)应该依赖于上层(抽象)。  换句话说上层策略性代码不应该依赖底层细节性代码，
底层细节性代码应该依赖上层策略性的代码。
包的内聚性三原則 ◆ REP:复用/发布等同原则(Release Reuse Equivalency Principle)
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/solid_1/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/err_return/">Go项目:error错误处理</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2019-02-14T08:38:02&#43;08:00">
          Feb 14, 2019
        </time>
      </div>
    </div>
  </header>
  <div>
    上一篇文章我介绍了拆分服务后如何去写测试代码。
Go项目:傻瓜式联合测试
今天想共享一下，我是如何处理error。
其实error是一个普通的处理。
但是你拆分服务后，一个功能调用多个api来实现的时候，错误处理是一件麻烦的事情。
有A,B,C 3个服务。 A服务提供的一个功能是需要 B和C 服务的信息。 该功能执行的时候出问题，单凭返回的信息，你是很难一眼看出问题点是在哪里。 (go 的错误提示过于简单...^^;;)  所以我自己写了处理error的一个package。
https://github.com/limingxie/taoyuan-kit/blob/master/errs/errs.go 实际运用例子 这是普通的处理方式
package main import ( &quot;fmt&quot; &quot;strconv&quot; ) func main() { value, err := returnValue() if err != nil { //普通的处理 fmt.Println(err) } else { fmt.Println(value) } } func returnValue() (int, error) { value, err := strconv.Atoi(&quot;string&quot;) if err != nil { //普通的处理 return 0, err } return value, nil }  执行结果
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/err_return/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/my_go_test4/">Go项目:傻瓜式联合测试</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2019-02-12T08:38:02&#43;08:00">
          Feb 12, 2019
        </time>
      </div>
    </div>
  </header>
  <div>
    现在微服务很流行，加上我的项目从10个表增加到30+表的业务量。
感觉有些内容不应该在同一个服务里。
于是我做了一个决定: 拆分服务。
分了4个服务后发现每个服务都不到8个表。每个服务的业务复杂度都不高。 心理暗自高兴，都说微服务，微服务，原来这么好？ 这种好心情维持不到半天，后面出的问题让我晕头转向。 踩了N多个坑...ㅠㅠ  今天我想说说其中的测试代码。
当我分了服务后写单元测试，其实没遇到过什么大问题。
可以使用上一篇文章介绍的测试替身。
Go项目的测试代码3（测试替身Test Double）
问题是每个服务的功能是需要调用其他的服务。 `单元测试没问题，不能确保联合调用没问题`。 (初期把单元测试过的代码直接发布运营，把我害惨了...)  我做了所有人都能想到的傻瓜式的联合测试方法。
简单，傻瓜式，但是很实用。 联合测试思路 就是把数据库(我是用mysql)和几个服务用docker容器启动，执行联合测试代码。
这跟本地运行每个服务后，运行测试代码有什么区别吗？(嘿嘿~ 自己想想吧。我也不知道~) 实际运用例子 有点linux和docker基础的人，不看下面的例子也能应该能想到怎么做的吧？
#deleted container and image, network docker rm -f a-service-api-container b-service-api-container... my-mysql 2&gt; /dev/null docker rmi -f a-service-api-image b-service-api-image ... 2&gt; /dev/null docker network rm my-network 2&gt; /dev/null echo '' echo '&lt;============== start =============&gt;' #create docker network docker network create my-network echo 'mysql starting .
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/my_go_test4/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
</div>
<nav class="pagination" role="navigation">

  <hr />


  <span class="page-number">Page 1 of 4</span>

<a class="older-posts" href="/page/2/">Older Posts <span aria-hidden="true">&raquo;</span></a>

</nav>

  </main>
  <footer class="container global-footer">
    <div class="copyright-note pull-left">
      limingxie - blog
    </div>
    <div class="sns-links hidden-print">
  
  <a href="mailto:li_mingxie@163.com">
    <i class="fa fa-envelope"></i>
  </a>
  
  
  
  
  
  
  
  
  
  
  
  
</div>

  </footer>

  <script src="https://limingxie.github.io/js/highlight.pack.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
  
  
</body>
</html>



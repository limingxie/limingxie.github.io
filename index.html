<!DOCTYPE html>
<html lang="en-us">
<head prefix="og: http://ogp.me/ns#">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <meta property="og:title" content=" li_mingxie - Blog" />
  
  <meta name="theme-color" content="#hexcolor" />
 
  <meta property="og:site_name" content="li_mingxie - Blog" />
  <meta property="og:url" content="https://limingxie.github.io/" />
  
  
  <meta property="og:type" content="website" />
  

  <title>
     li_mingxie - Blog
  </title>

  <link rel="stylesheet" href="https://limingxie.github.io/css/bootstrap.min.css" />
  <link rel="stylesheet" href="https://limingxie.github.io/css/main.css" />
  <link rel="stylesheet" href="https://limingxie.github.io/css/font-awesome.min.css" />
  <link rel="stylesheet" href="https://limingxie.github.io/css/github.css" />
 
  <link rel="shortcut icon" href="https://limingxie.github.io/images/favicon.ico" />
  <link rel="apple-touch-icon" href="https://limingxie.github.io/images/apple-touch-icon.png" />
  
  <link href="https://limingxie.github.io/index.xml" rel="alternate" type="application/rss+xml" title="li_mingxie - Blog" />
  

  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1333035c981597c935706422cb31b76b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
    
</head>
<body>
    <header class="global-header"  style="background-image:url( /images/bg.jpg )">
    <section class="header-text">
      <h1><a href="https://limingxie.github.io/">li_mingxie - Blog</a></h1>
      
      <div class="sns-links hidden-print">
  
  <a href="mailto:li_mingxie@163.com">
    <i class="fa fa-envelope"></i>
  </a>
  
  
  
  
  
  
  
  
  
  
  
  
</div>

      
      
      <a href="https://limingxie.github.io/index.xml" class="btn-header btn-subscribe hidden-xs">
        <i class="fa fa-rss" aria-hidden="true"></i>
        &nbsp;Subscribe
      </a>
      
    </section>
  </header>
  <main class="container">

<div class="article-list">
  
  
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/err_return/">Go项目:error错误处理</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2019-02-14T08:38:02&#43;08:00">
          Feb 14, 2019
        </time>
      </div>
    </div>
  </header>
  <div>
    上一篇文章我介绍了拆分服务后如何去写测试代码的。
Go项目:傻瓜式联合测试
今天想共享一下，我是如何处理error的。
其实error是一个普通的处理。
但是你拆分服务后，一个功能调用多个api来实现的时候，错误处理是一件麻烦的事情。
有A,B,C 3个服务。 A服务提供的一个工能是需要 B和C 服务的信息。 该功能执行的时候报错，单凭返回的错误信息，你是很难一眼看出问题点是在哪里。 (go 的错误提示过于简单...^^;;)  所以我自己写了处理error的一个package。
https://github.com/limingxie/taoyuan-kit/blob/master/errs/errs.go 实际运用例子 这是普通的处理方式
package main import ( &quot;fmt&quot; &quot;strconv&quot; ) func main() { value, err := returnValue() if err != nil { //普通的处理 fmt.Println(err) } else { fmt.Println(value) } } func returnValue() (int, error) { value, err := strconv.Atoi(&quot;string&quot;) if err != nil { //普通的处理 return 0, err } return value, nil }  执行结果
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/err_return/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/my_go_test4/">Go项目:傻瓜式联合测试</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2019-02-12T08:38:02&#43;08:00">
          Feb 12, 2019
        </time>
      </div>
    </div>
  </header>
  <div>
    现在微服务很流行，加上我的项目从10个表增加到30+表的业务量。
感觉有些内容不应该在同一个服务里。
于是我做了一个决定: 拆分服务。
分了4个服务后发现每个服务都不到8个表。每个服务的业务复杂度都不高。 心理暗自高兴，都说微服务，微服务，原来这么好？ 这种好心情维持不到半天，后面出的问题让我晕头转向。 踩了N多个坑...ㅠㅠ  今天我想说说其中的测试代码。
当我分了服务后写单元测试，其实没遇到过什么大问题。
可以使用上一篇文章介绍的测试替身。
Go项目的测试代码3（测试替身Test Double）
问题是每个服务的功能是需要调用其他的服务。 `单元测试没问题，不能确保联合调用没问题`。 (初期把单元测试过的代码直接发布运营，把我害惨了...)  我做了所有人都能想到的傻瓜式的联合测试方法。
简单，傻瓜式，但是很实用。 联合测试思路 就是把数据库(我是用mysql)和几个服务用docker容器启动，执行联合测试代码。
这跟本地运行每个服务后，运行测试代码有什么区别吗？(嘿嘿~ 自己想想吧。我也不知道~) 实际运用例子 有点linux和docker基础的人，不看下面的例子也能应该能想到怎么做的吧？
#deleted container and image, network docker rm -f a-service-api-container b-service-api-container... my-mysql 2&gt; /dev/null docker rmi -f a-service-api-image b-service-api-image ... 2&gt; /dev/null docker network rm my-network 2&gt; /dev/null echo '' echo '&lt;============== start =============&gt;' #create docker network docker network create my-network echo 'mysql starting .
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/my_go_test4/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/work_note/">工作中我们常见的误解</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-12-23T07:28:49&#43;08:00">
          Dec 23, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    虽然我不是什么大领导或是一个高管。
但是看那些尤其是不满5年的员工们对工作的误解。
让我感到无法用语言形容的发闷。。。
而且组长的真心建议组员们一般都会有反感，以为组长对自己做“洗脑工作”。
我简单的整理了几个常见的误解。
1. 我的组长是“加班狂”，“工作狂”。 我经常听到这句话： 组长总是加班，害的我不能及时下班。 每次下班的时候，总是要看组长的脸色。  其实组长也是人，他也有家庭。
如果不是自己的公司，任何一个人都不会喜欢加班的！
那他们为什么总是加班呢？
很简单，要么工作还没做完，要么有什么苦恼。
为什么啊？ 你觉得没有更多的事情要做啊？
也很简单。
要么你能力不够，不能把活分给你做。
要么你在组长心目中的地位，连这些苦恼也不够分享。
虽然这句话说的有点偏激。但是你如果不知道上司为什么加班。
是不是要主动的尝试一下去了解或帮忙一起解决问题呢？
2. 我需要私人空间，下班后不要找我。 我从事的工作是IT行业。
有时候系统出问题，找相关负责人解决问题。 经常会听到这样的答复： 我没带有电脑，不太方便确认。 我会(明天)下周一去公司确认的。  这句话说得合情合理。 但是你如果不能及时处理这些事故，公司的损失会不会更大？
你要明白这个道理：
如果你不是24小时待命的状态，公司的核心业务永远不会和你有关系的。
这是让人很不舒服的现实，你准备接受这个现实了吗？
3. 我很努力工作，为什么还没晋升？ 有些人嘴里说很努力工作，但是实际行动却不是。
上班的时间大家都很忙，不忙的是要被开除的人。
我要成为专业技术人员(可是1年连一本技术书籍也不看) 我想成为优秀的领导(可是连公司的目标是什么都不知道) ... ...  真正有目标，有理想的人至少1天会多抽出工作以外的2，3个小时为自己投资。
1周至少抽出10~20个小时，为自己的未来学习。
其实大部分的新员工都只是沉浸在自己的世界里，认为自己很努力。
习惯性的高估自己，其实你不是自己想象中的那么重要，厉害的人。
每个人都有自己的观点，有自己的思想和想法。
如果看了这个文章让你不舒服了，我感到抱歉。
不同意我的观点，可以骂我，当我是一个装逼的傻鸟吧&hellip;^^
欢迎大家的意见和交流
email: li_mingxie@163.com
  </div>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/go_socket/">go websocket的简单应用</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-12-06T07:28:49&#43;08:00">
          Dec 6, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    因为我们是做企业ERP系统，没什么机会接触socket。
这次准备做消息推送才了解到还有socket这种技术&hellip;ㅠㅠ
(做了这么多年的程序员，连这个也不知道&hellip;ㅠㅠ)
具体的概念就不在这里多做解释了，可以百度或谷歌搜一下。
我做了一个简单的demo，以便于了解使用方式。
demo大致构建了如下的场景。
图片备用地址
Dial(用户) package main import ( &quot;log&quot; &quot;golang.org/x/net/websocket&quot; ) func main() { origin := &quot;http://localhost/&quot; url := &quot;ws://localhost:5001/test&quot; //创建websocket链接 ws, err := websocket.Dial(url, &quot;&quot;, origin) if err != nil { log.Fatal(err) } var s string for { //等待websocket的消息(这个过程是bolck) err := websocket.Message.Receive(ws, &amp;s) if err != nil { log.Println(err) ws.Close() break } log.Println(s) } }  
Handle(SocketServer) package main import ( &quot;log&quot; &quot;net/http&quot; &quot;sync&quot; &quot;github.
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/go_socket/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/development_responsibility/">我们(开发者)的责任</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-11-14T05:28:49&#43;08:00">
          Nov 14, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    开发者写错的代码发布到运营，出问题了。
谁来承担责任？
◆ 运营发布后出了问题，第一责任人不是我们 经常听到的解释是写代码的开发者不是第一责任人。
第一责任人应该是公司老板，
之后是项目负责人，
之后是QA,
之后是CodeReview的人，
最后才轮到写代码的开发者。
那我们开发者真的没有责任吗？
我们开发者的责任是什么？
◆ 我们不用承担任何的责任吗？ 举一个例子。你跟家人一起在海边度假。 你写的项目出问题了，你的同事解决不了问题。 联系上你了。你会怎么做？ 你会说CodeReview的时候怎么没发现？ QA怎么没发现？... 出了问题让我牺牲个人休假的时间解决问题？  我有女儿，现在上幼儿园。 在幼儿园不小心打哭了别家小朋友。怎么办？ 论责任第一责任当然是幼儿园老师没有看好孩子。 那我就没有一点的责任吗？我不需要做任何的事情吗？ 至少应该像孩子的父母道歉，之后教孩子不要犯同样的错误。  那我写的代码呢？
把自己写的代码看做为自己的孩子，这么高尚的话可能不适合我们。
但是身为成年人，我们都知道自己做错的事情，自己需要承担责任。
其实工作中我不太喜欢责任这个单词
因为追究责任很容易发生相互推卸责任。当发生事故，或是错误的时候，
我们第一反应该是如何去解决这个问题。而不是寻找责任人是谁，谁来背这个黑锅。
◆ 那我们应该怎么做？ 回到上面举得例子。出问题了。
你会放弃你的度假，解决这次问题吗？
还是先拖着尽可能让你的同事帮你解决？ 或是晚上回到宾馆再帮他们处理吗？
我们希望当然是后者，事情不紧急的时候我们完全不需要牺牲你的假期。
但是万一这是十分紧急的事情呢？
很遗憾的告诉你，你不想听的建议：
兄弟，你应该回去处理。因为这才是专业表现
(这里指的当然不是公司，你需要去有电脑，有网的地方解决问题。)
无论你在做什么？ 你要对自己的写的代码负起责任。
因为程序的错误而产生的经济损失，有可能是你的老板去承担。
但是至少你有责任，把有问题的代码修改正确。
什么时候改？ 不紧急，你可以慢慢改。
紧急? 对不起，你得马上处理了。
你的女人在幼儿园打了别的小朋友你不管吗？
你也可以不管，你可以表现的不专业。
之后这件事情会传遍幼儿园。
其他家长远离你，其他孩子远离你的孩子。
◆ 我们需要对自己写的代码负责 哪怕是10年前写代码，如果是你写过的代码。(前提是没有人动过~)
因为你写错的原因出的bug你就有责任去修改它。
(这里不包含新需求的添加，以及环境的变化出现的问题。) 

 是的，我们是开发者。 我们需要负的责任就是我们自己写的代码。  欢迎大家的意见和交流
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/development_responsibility/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/do_change/">一个小小变化的威力</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-11-11T05:28:49&#43;08:00">
          Nov 11, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    今天是双11，本想来公司凑凑热闹&hellip;^^
结果主要问题都是在我的服务里，还把登录给整瘫了半个多小时&hellip;ㅠㅠ
高峰过去了，可以松口气了~ 抽个时间写写博文。
这次我想共享我们公司一个部门遇到的事情。
那天我正在为拆分服务的问题而苦恼着。
(本来是一个的服务拆分成4个服务，问题巨多&hellip;ㅠㅠ)
有位同事(韩国人)跟我说，看到了一些不太正常的请求。
希望我帮他和相关负责人沟通。(我是朝鲜族，有时候会帮他们沟通)。
在沟通的过程当中，我感觉到这是一个很有趣的问题。
◆ 为什么会有这么多的请求？ 先简单的说一下业务吧。
线上(天猫商城)出售一笔商品，线下的卖场会把这个单子抢过来，自行给购物者发货。
全国各地的卖场会积极的抢线上出售过的单子，因为每抢到一笔单子，他们就有提成赚。
所以比较勤奋的卖场人员只要店里没有顾客的话就会不停的刷单。
(不停的给服务器发Request请求，看看有没有可抢的单子。)
有些喜欢思考的人就会问，那不能做成推单吗？
这样就没有这种查询的压力了。为什么不那么做的种种原因这里就不做解释了。
那问题是什么呢？其实就是请求量异常的的多。
在我们不怎么注意的情况下，Request请求量1个月内翻了6倍！
不可能吧？当时是9~10月份。又不是双11，又不是做了什么活动&hellip;
卖场数量没什么太多的变化，这请求数量怎么会上升的这么快？
◆ 原来是有人用脚本刷单啊？ 我们赶紧查看了一下日志，发现有几个卖场的请求比较异常。
1个卖场1天内请求量居然达到了10万次。
1秒一次也是刷20个小时也只能刷7.2万次。10万次太夸张了吧？
而且我们在前端做了限制3秒才能刷一次。
问题应该明确了，这几家卖场肯定是在用脚本刷单。
而且是有写计算机基础的人获取后台api的url刷单。
◆ 好像不对？日志证明不了有人用脚本刷单 但是我们看了前一天的日志，傻眼了。
请求量最高的卖场不停的变。
这就不能证明这些卖场人员是用脚本刷单了。
用脚本刷单的卖场，应该是每天都会刷单吧？ 而且请求量最高的卖场分布在全国各地区，
今天是这家卖场，明天又是另一家卖场&hellip;.ㅠㅠ
我们开始怀疑我们的程序有问题了。
前端是不是有bug在特定的情况下会不停的发请求?
企业微信是不是有我们不知道的bug? (我的的应用是嵌套到企业微信的。) 开始争辩:
项目的负责人说我们的程序绝不会有这样的问题。
我们反问你怎么证明你的程序是没问题？
如果是企业微信的问题，我们怎么证明这是企业微信的问题？
◆ 虽然不知道怎么办，但是我们可以做一些改变 争论一番后，大家都累了。不知道怎么解决这件事情。
大家你看我，我看你~ 都等着别人出方案&hellip;^^;;
这怎么办啊？联系了卖场，卖场负责人说我们这里没有异常~ 也不承认自己用了什么脚本。
(这举动很傻，如果我是卖场人员，即使用了我也不会承认自己用了脚本刷单。)
这时候我们发现这个api没有做身份验证。我们提议要不要做身份验证？
(至于为什么不做身份验证，好不专业之类的评价我不做解释了~)
这是一个比较古老的api，而且过些日子会有新的api代替他的。
所以相关的负责人是不怎么希望动这套代码。
而且做身份验证是解决不了这个古怪的现象的。
最后我们决定加身份验证看看，当时大部分的人都认为做身份验证没什么用。
没事找事，这老代码改动后，万一报错怎么办？
虽然我们不知道有什么效果，或是给我们带来什么？
总比什么都不做强吧？
◆ 加了身份验证没什么效果啊？ 添加身份验证功能以后，早上我们紧急发布了新版本。
看了日志，我们失算了~ 没效果&hellip;ㅠㅠ
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/do_change/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/work_sharing/share_001/">技术Leader需要哪些能力？</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-09-24T07:28:49&#43;08:00">
          Sep 24, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    身为一个高龄开发者(30岁以上应该都属于高领开发者吧？ 这世道&hellip;ㅠㅠ)，
我也一样(35岁&hellip;ㅠㅠ)，对以后的职业发展有很多苦恼。
我是幸运的，因为我们公司有一位高龄的技术牛人。
让我看到了一丝希望。原来做技术也可以做到这种程度。
(写了好几本书，开源代码社区的CodeReviewer，我问的问题没有一个回答不了的。)
前些天有幸和这位牛人做了一些工作上的交流，
如何做好技术Leader，让我感触特别的深刻。
以下是他给我的建议以及我自己的感触，想和大家一起分享。
快速的转换思维的能力 我们写代码的时候不喜欢被打扰，谁也不喜欢自己聚精会神的工作的时候有人过来打扰自己。
但是大部分的情况下，我们不是单打独斗。
身为技术Leader，我们就有义务去协助组员。
当我们有一定的能力以后，甚至需要协助几个小组或全公司的技术。
在这种情况下，如果拒绝被打扰，等于是不想做这个技术Leader。
我们需要学会`快速的进入角色`，进入时间越短越好。 一般情况下，别人做一些复杂的开发的时候需要5~10分钟去`从新进入状态`的话， 我们要在1分钟内，甚至30秒内要进入状态。 哪怕是自己的开发，或是其他人问题的解答。`必须快速的进入状态去解决问题。` A过来问，解答后我们用5分钟的时间调整状态做自己的事情，刚准备好B过来了。 等把B的问题看完后，再用5分钟的时间调节自己的状态，过了不到10分钟，C又过来问.... 等着晚上加班做自己的事情吧...^^||  所以快速的转换思维进入状态能力很重要，需要有意的去提高这个能力才行。
细分工作的能力 身为技术Leader现在准备好随时被打扰了吗？
随时被打扰，我们的工作就不做了吗？
所以我们还需要细分工作，分的颗粒度越小越好。
我一般喜欢这种编程方式。 觉得这是一个比较复杂的内容，'就直接写个空的方法。先返回null。' 走下一个逻辑。`先把这个流程或是这个逻辑走完。` 之后再写刚才觉得复杂的那个方法。 这么写话，每个函数所实现的内容不多，中间被打断也是很容易从新进入状态。 也可以先让问问题的人等几分钟，先把这个逻辑写完后，再一起讨论他的问题。  所以提高细分工作的能力会让不断的打扰中，保持工作的节奏和状态。
不断的摸索提高自己的开发效率的方法 不断的被打扰，不断的开会。
让技术Leader们很难有充分的时间去编程。
那技术Leader就不需要写代码吗？
或是写很少一部分的代码就可以了吗？
其实不是，为了保持自己对技术感觉，我们还需要不断的写代码。
那怎么办？
这会要求我们别人写2个小时的内容，我么是要在1小时甚至半小时内写完。
需要不断的去找合适自己，提高自己效率的方法。 举例子，合理的运用快捷键。command + ~ , command + -&gt;... git的gcb, ga, gcmsg, ggpull, ggpush, glum, glog ... vsCode的多行修改， opton + 方向键，control + -&gt; ... 合理的分配屏幕的结构，左边数据库，中间代码窗，下面zsh窗，右边postman等等... 我们需要不断思考，寻找对自己合适的开发方式。 还有最重要的一项'提高整体的技术能力以及思维能力。'  不断的摸索提高自己的开发效率的方法，学会短时间内出满意的产出物。
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/work_sharing/share_001/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/linux_command/">linux 常用命令整理(一)</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-09-02T07:28:49&#43;08:00">
          Sep 2, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    这么晚了才认识了linux系统。感觉越来越喜欢linux系统了。
废话少说，这几天自己做的笔记，炫耀一下&hellip;.^^
方便以后用的时候查找。
 命令行 备注   pwd: 改变目录 cd..   ls: 列出目录内容 ls -l = ll  ls -l t 时间排序 S 大小排序 -d 目录  ls -lt --reverse  ls -F 所有文件  Ls -i 查看所有节点inodemv    file: 确定文件类型   less: 查看文件内容   cp: 复制文件和目录 -a 复制所有文件一起权限 -r 递归复制 -u 复制没有或更新的内容  cp file1 file2 dir1 复制文件file1和file2 到dir1   mv: 移动或重命名文件夹和目录 -i 操作需要做确认 -u -v 显示信息  mv file1 file2 file1移动到file2 或重命名file2  mv file1 file2 dir1 将file1,file2 移动到dir1 前提是dir1必须存在   mkdir: 创建目录   rm: 移除文件盒目录 危险的命令，先用ls 看看是不是你要删除的文件，在换成rm执行。  -i 需要确认删除 -r 递归删除 -f --force 忽略提示全部删除 -v 查看信息  rm -rf file1 dir1 删除 file1和dir2 并且不提示执行删除   ln: 创建硬链接和符号链接  in file link 创建硬链接  in -s item link 创建符号链接，这里item可以是目录   通配符 g* g开头的任意文件  b*.
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/linux_command/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/solid/">solid原则简单笔记</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-09-01T07:28:49&#43;08:00">
          Sep 1, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    这些天因为工作上的需求，一套代码部署到不同的环境里。
虽然说是一样的业务，但是在不同的环境里难免会有一些少许不同的业务。
刚开始的时候觉得没什么问题，分了几个分支。
但是后来感觉越来越不对劲了，不同的环境分不同的分支，以为是很简单的事情。
时间长了，分支之间的差异也越来越大，感觉应该分不同的仓库。
这分了仓库问题又来了，改了Bug需要再不同的仓库里重复的修改代码，审查代码，合并代码，测试&hellip;
把我忙的不亦乐乎。
这让我怀疑，是不是代码结构本身有问题？
虽然现在用的Go语言不是面向对象编程语言，
但是我觉得经典的面向对象编程思想应该能对我有帮助。
查到了一个很有趣的原则：solid原则。
当做自己的笔记简单的整理了一下solid原则。
SRP	The Single Responsibility Principle	单一责任原则 OCP	The Open Closed Principle	开放封闭原则 LSP	The Liskov Substitution Principle	里氏替换原则 ISP	The Interface Segregation Principle	接口分离原则 DIP	The Dependency Inversion Principle	依赖倒置原则  ◆ 单一责任原则(The Single Responsibility Principle)
一个类只完成它应该完成的职责。  这一原则其实项目刚开始的时候很容易遵守。
但是项目久了后，你会发现你的项目越来越变味儿。
需要不断的重构中，维持单一责任原则。
◆ 开放封闭原则(The Open Closed Principle)
软件实体(类,模块,函数等等)应当对扩展开放，对修改闭合。  好难好难。
尤其是api的版本不断的升级，老版本的api又不能弃用的时候，
而且结构在不断的变化的时候&hellip;ㅠㅠ
◆ 里氏替换原则(The Liskov Substitution Principle)
只有在确定是 is-a 的关系时才能使用继承。  这一原则我刚开始的时候还真不理解。其实很简单。
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/solid/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/git_cherry_pick/">git命令 cherry-pick 的使用简介</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-07-30T07:28:49&#43;08:00">
          Jul 30, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    上一篇文章介绍了merge和rebase的用法以及原理。
git命令merge和rebase的简单应用
这里简单的介绍一下 cherry-pick 的用法。
什么时候会用到 cherry-pick 命令？
代码分几个大分支，各自有不同的功能在开发，这时候我们就有这样的需求。
只合并某个分支上的某次修改commit到指定的分支上。
这时候就可以使用cherry-pick命令来操作。
$ git cherry-pick commit_id //想合并的commit_id  图片备用地址
如果是图1这样使用cherry-pick命令的话，
会有 a1, a2, a3 的合并项，在代码中需要删除 a1, a2 再次提交解决冲突才行。
喜欢找茬的人会这么问：这么一来和merge有什么区别吗？
merge的话也不是把 a1, a2, a3 的代码合并过来吗？
merge合并后把 a1, a2 删掉的话跟cherry-pick有什么区别？
区别在于日志。
$ git cherry-pick fd4e09c(a3的 commit_id) error: could not apply fd4e09c... add a3 hint: after resolving the conflicts, mark the corrected paths hint: with 'git add &lt;paths&gt;' or 'git rm &lt;paths&gt;' hint: and commit the result with 'git commit' //.
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/git_cherry_pick/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
</div>
<nav class="pagination" role="navigation">

  <hr />


  <span class="page-number">Page 1 of 2</span>

<a class="older-posts" href="/page/2/">Older Posts <span aria-hidden="true">&raquo;</span></a>

</nav>

  </main>
  <footer class="container global-footer">
    <div class="copyright-note pull-left">
      limingxie - blog
    </div>
    <div class="sns-links hidden-print">
  
  <a href="mailto:li_mingxie@163.com">
    <i class="fa fa-envelope"></i>
  </a>
  
  
  
  
  
  
  
  
  
  
  
  
</div>

  </footer>

  <script src="https://limingxie.github.io/js/highlight.pack.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
  
  
</body>
</html>



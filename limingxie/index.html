<!DOCTYPE html>
<html lang="en-us">
<head prefix="og: http://ogp.me/ns#">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <meta property="og:title" content=" Limingxies &middot;  li_mingxie - Blog" />
  
  <meta name="theme-color" content="#hexcolor" />
 
  <meta property="og:site_name" content="li_mingxie - Blog" />
  <meta property="og:url" content="https://limingxie.github.io/limingxie/" />
  
  
  <meta property="og:type" content="website" />
  

  <title>
     Limingxies &middot;  li_mingxie - Blog
  </title>

  <link rel="stylesheet" href="https://limingxie.github.io/css/bootstrap.min.css" />
  <link rel="stylesheet" href="https://limingxie.github.io/css/main.css" />
  <link rel="stylesheet" href="https://limingxie.github.io/css/font-awesome.min.css" />
  <link rel="stylesheet" href="https://limingxie.github.io/css/github.css" />
 
  <link rel="shortcut icon" href="https://limingxie.github.io/images/favicon.ico" />
  <link rel="apple-touch-icon" href="https://limingxie.github.io/images/apple-touch-icon.png" />
  

  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1333035c981597c935706422cb31b76b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
    
</head>
<body>
    <header class="global-header"  style="background-image:url( /images/bg.jpg )">
    <section class="header-text">
      <h1><a href="https://limingxie.github.io/">li_mingxie - Blog</a></h1>
      
      <div class="sns-links hidden-print">
  
  <a href="mailto:li_mingxie@163.com">
    <i class="fa fa-envelope"></i>
  </a>
  
  
  
  
  
  
  
  
  
  
  
  
</div>

      
      <a href="https://limingxie.github.io/" class="btn-header btn-back hidden-xs">
        <i class="fa fa-angle-left" aria-hidden="true"></i>
        &nbsp;Home
      </a>
      
      
      <a href="https://limingxie.github.io/limingxie/index.xml" class="btn-header btn-subscribe hidden-xs">
        <i class="fa fa-rss" aria-hidden="true"></i>
        &nbsp;Subscribe
      </a>
      
    </section>
  </header>
  <main class="container">

<section class="article-list">
  <h1>Limingxies</h1>
  
  <hr/>
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/solid_1/">设计原则那些事儿</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2019-06-06T07:28:49&#43;08:00">
          Jun 6, 2019
        </time>
      </div>
    </div>
  </header>
  <div>
    代码架构的设计原则中最普遍的是solid原则。
SRP	Single Responsibility Principle	单一责任原则 OCP	Open Closed Principle	开放封闭原则 LSP	Liskov Substitution Principle	里氏替换原则 ISP	Interface Segregation Principle	接口分离原则 DIP	Dependency Inversion Principle	依赖反转原则   ◆ SRP:单一责任原则(Single Responsibility Principle)
一个类只完成它应该完成的职责。  任何一个软件模块都应该只对某一类行为者负责。 它的作用就是告诉我们在哪里划清边界。
◆ OCP:开放封闭原则(Open Closed Principle)
软件实体(类,模块,函数等等)应当对扩展开放，对修改闭合。  这其实就是要关注，增加新的功能的时候能不能不修改以前旧代码？
增加新功能，需要大改旧代码，说明没做好开放封闭原则。
◆ LSP:里氏替换原则(Liskov Substitution Principle)
模块之间应能自由替换。  其实就是替换别的模块的时候不应该影响别的模块，导致发生修改事项。
◆ ISP:接口分离原则(Interface Segregation Principle)
如果一个接口包含了过多的方法，应该通过分离接口将其拆分。  如果依赖和自己没有关系或不需要的东西，需要应该把他拆分，只依赖和自己有关系的不分。
◆ DIP:依赖反转原则(Dependency Inversion Principle)
上层(抽象)不应该依赖于下层(实体)，下层(实体)应该依赖于上层(抽象)。  换句话说上层策略性代码不应该依赖底层细节性代码，
底层细节性代码应该依赖上层策略性的代码。
包的内聚性三原則 ◆ REP:复用/发布等同原则(Release Reuse Equivalency Principle)
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/solid_1/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  <hr/>
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/err_return/">Go项目:error错误处理</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2019-02-14T08:38:02&#43;08:00">
          Feb 14, 2019
        </time>
      </div>
    </div>
  </header>
  <div>
    上一篇文章我介绍了拆分服务后如何去写测试代码。
Go项目:傻瓜式联合测试
今天想共享一下，我是如何处理error。
其实error是一个普通的处理。
但是你拆分服务后，一个功能调用多个api来实现的时候，错误处理是一件麻烦的事情。
有A,B,C 3个服务。 A服务提供的一个功能是需要 B和C 服务的信息。 该功能执行的时候出问题，单凭返回的信息，你是很难一眼看出问题点是在哪里。 (go 的错误提示过于简单...^^;;)  所以我自己写了处理error的一个package。
https://github.com/limingxie/taoyuan-kit/blob/master/errs/errs.go 实际运用例子 这是普通的处理方式
package main import ( &quot;fmt&quot; &quot;strconv&quot; ) func main() { value, err := returnValue() if err != nil { //普通的处理 fmt.Println(err) } else { fmt.Println(value) } } func returnValue() (int, error) { value, err := strconv.Atoi(&quot;string&quot;) if err != nil { //普通的处理 return 0, err } return value, nil }  执行结果
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/err_return/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  <hr/>
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/my_go_test4/">Go项目:傻瓜式联合测试</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2019-02-12T08:38:02&#43;08:00">
          Feb 12, 2019
        </time>
      </div>
    </div>
  </header>
  <div>
    现在微服务很流行，加上我的项目从10个表增加到30+表的业务量。
感觉有些内容不应该在同一个服务里。
于是我做了一个决定: 拆分服务。
分了4个服务后发现每个服务都不到8个表。每个服务的业务复杂度都不高。 心理暗自高兴，都说微服务，微服务，原来这么好？ 这种好心情维持不到半天，后面出的问题让我晕头转向。 踩了N多个坑...ㅠㅠ  今天我想说说其中的测试代码。
当我分了服务后写单元测试，其实没遇到过什么大问题。
可以使用上一篇文章介绍的测试替身。
Go项目的测试代码3（测试替身Test Double）
问题是每个服务的功能是需要调用其他的服务。 `单元测试没问题，不能确保联合调用没问题`。 (初期把单元测试过的代码直接发布运营，把我害惨了...)  我做了所有人都能想到的傻瓜式的联合测试方法。
简单，傻瓜式，但是很实用。 联合测试思路 就是把数据库(我是用mysql)和几个服务用docker容器启动，执行联合测试代码。
这跟本地运行每个服务后，运行测试代码有什么区别吗？(嘿嘿~ 自己想想吧。我也不知道~) 实际运用例子 有点linux和docker基础的人，看下面的脚本应该能想到怎么做的吧？
#deleted container and image, network docker rm -f a-service-api-container b-service-api-container... my-mysql 2&gt; /dev/null docker rmi -f a-service-api-image b-service-api-image ... 2&gt; /dev/null docker network rm my-network 2&gt; /dev/null echo '' echo '&lt;============== start =============&gt;' #create docker network docker network create my-network echo 'mysql starting .
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/my_go_test4/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  <hr/>
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/work_note/">工作中我们常见的误解</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-12-23T07:28:49&#43;08:00">
          Dec 23, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    虽然我不是什么大领导或是一个高管。
但是看那些尤其是不满5年的员工们对工作的误解。
让我感到无法用语言形容的发闷。。。
而且组长的真心建议组员们一般都会有反感，以为组长对自己做“洗脑工作”。
我简单的整理了几个常见的误解。
1. 我的组长是“加班狂”，“工作狂”。 我经常听到这句话： 组长总是加班，害的我不能及时下班。 每次下班的时候，总是要看组长的脸色。  其实组长也是人，他也有家庭。
如果不是自己的公司，任何一个人都不会喜欢加班的！
那他们为什么总是加班呢？
很简单，要么工作还没做完，要么有什么苦恼。
为什么啊？ 你觉得没有更多的事情要做啊？
也很简单。
要么你能力不够，不能把活分给你做。
要么你在组长心目中的地位，连这些苦恼也不够分享。
虽然这句话说的有点偏激。但是你如果不知道上司为什么加班。
是不是要主动的尝试一下去了解或帮忙一起解决问题呢？
2. 我需要私人空间，下班后不要找我。 我从事的工作是IT行业。
有时候系统出问题，找相关负责人解决问题。 经常会听到这样的答复： 我没带有电脑，不太方便确认。 我会(明天)下周一去公司确认的。  这句话说得合情合理。 但是你如果不能及时处理这些事故，公司的损失会不会更大？
你要明白这个道理：
如果你不是24小时待命的状态，公司的核心业务永远不会和你有关系的。
这是让人很不舒服的现实，你准备接受这个现实了吗？
3. 我很努力工作，为什么还没晋升？ 有些人嘴里说很努力工作，但是实际行动却不是。
上班的时间大家都很忙，不忙的是要被开除的人。
我要成为专业技术人员(可是1年连一本技术书籍也不看) 我想成为优秀的领导(可是连公司的目标是什么都不知道) ... ...  真正有目标，有理想的人至少1天会多抽出工作以外的2，3个小时为自己投资。
1周至少抽出10~20个小时，为自己的未来学习。
其实大部分的新员工都只是沉浸在自己的世界里，认为自己很努力。
习惯性的高估自己，其实你不是自己想象中的那么重要，厉害的人。
每个人都有自己的观点，有自己的思想和想法。
如果看了这个文章让你不舒服了，我感到抱歉。
不同意我的观点，可以骂我，当我是一个装逼的傻鸟吧&hellip;^^
欢迎大家的意见和交流
email: li_mingxie@163.com
  </div>
  
</article>

  
  <hr/>
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/go_socket/">go websocket的简单应用</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-12-06T07:28:49&#43;08:00">
          Dec 6, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    因为我们是做企业ERP系统，没什么机会接触socket。
这次准备做消息推送才了解到还有socket这种技术&hellip;ㅠㅠ
(做了这么多年的程序员，连这个也不知道&hellip;ㅠㅠ)
具体的概念就不在这里多做解释了，可以百度或谷歌搜一下。
我做了一个简单的demo，以便于了解使用方式。
demo大致构建了如下的场景。
图片备用地址
Dial(用户) package main import ( &quot;log&quot; &quot;golang.org/x/net/websocket&quot; ) func main() { origin := &quot;http://localhost/&quot; url := &quot;ws://localhost:5001/test&quot; //创建websocket链接 ws, err := websocket.Dial(url, &quot;&quot;, origin) if err != nil { log.Fatal(err) } var s string for { //等待websocket的消息(这个过程是bolck) err := websocket.Message.Receive(ws, &amp;s) if err != nil { log.Println(err) ws.Close() break } log.Println(s) } }  
Handle(SocketServer) package main import ( &quot;log&quot; &quot;net/http&quot; &quot;sync&quot; &quot;github.
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/go_socket/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  <hr/>
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/development_responsibility/">我们(开发者)的责任</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-11-14T05:28:49&#43;08:00">
          Nov 14, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    开发者写错的代码发布到运营，出问题了。
谁来承担责任？
◆ 运营发布后出了问题，第一责任人不是我们 经常听到的解释是写代码的开发者不是第一责任人。
第一责任人应该是公司老板，
之后是项目负责人，
之后是QA,
之后是CodeReview的人，
最后才轮到写代码的开发者。
那我们开发者真的没有责任吗？
我们开发者的责任是什么？
◆ 我们不用承担任何的责任吗？ 举一个例子。你跟家人一起在海边度假。 你写的项目出问题了，你的同事解决不了问题。 联系上你了。你会怎么做？ 你会说CodeReview的时候怎么没发现？ QA怎么没发现？... 出了问题让我牺牲个人休假的时间解决问题？  我有女儿，现在上幼儿园。 在幼儿园不小心打哭了别家小朋友。怎么办？ 论责任第一责任当然是幼儿园老师没有看好孩子。 那我就没有一点的责任吗？我不需要做任何的事情吗？ 至少应该像孩子的父母道歉，之后教孩子不要犯同样的错误。  那我写的代码呢？
把自己写的代码看做为自己的孩子，这么高尚的话可能不适合我们。
但是身为成年人，我们都知道自己做错的事情，自己需要承担责任。
其实工作中我不太喜欢责任这个单词
因为追究责任很容易发生相互推卸责任。当发生事故，或是错误的时候，
我们第一反应该是如何去解决这个问题。而不是寻找责任人是谁，谁来背这个黑锅。
◆ 那我们应该怎么做？ 回到上面举得例子。出问题了。
你会放弃你的度假，解决这次问题吗？
还是先拖着尽可能让你的同事帮你解决？ 或是晚上回到宾馆再帮他们处理吗？
我们希望当然是后者，事情不紧急的时候我们完全不需要牺牲你的假期。
但是万一这是十分紧急的事情呢？
很遗憾的告诉你，你不想听的建议：
兄弟，你应该回去处理。因为这才是专业表现
(这里指的当然不是公司，你需要去有电脑，有网的地方解决问题。)
无论你在做什么？ 你要对自己的写的代码负起责任。
因为程序的错误而产生的经济损失，有可能是你的老板去承担。
但是至少你有责任，把有问题的代码修改正确。
什么时候改？ 不紧急，你可以慢慢改。
紧急? 对不起，你得马上处理了。
你的女人在幼儿园打了别的小朋友你不管吗？
你也可以不管，你可以表现的不专业。
之后这件事情会传遍幼儿园。
其他家长远离你，其他孩子远离你的孩子。
◆ 我们需要对自己写的代码负责 哪怕是10年前写代码，如果是你写过的代码。(前提是没有人动过~)
因为你写错的原因出的bug你就有责任去修改它。
(这里不包含新需求的添加，以及环境的变化出现的问题。) 

 是的，我们是开发者。 我们需要负的责任就是我们自己写的代码。  欢迎大家的意见和交流
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/development_responsibility/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  <hr/>
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/do_change/">一个小小变化的威力</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-11-11T05:28:49&#43;08:00">
          Nov 11, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    今天是双11，本想来公司凑凑热闹&hellip;^^
结果主要问题都是在我的服务里，还把登录给整瘫了半个多小时&hellip;ㅠㅠ
高峰过去了，可以松口气了~ 抽个时间写写博文。
这次我想共享我们公司一个部门遇到的事情。
那天我正在为拆分服务的问题而苦恼着。
(本来是一个的服务拆分成4个服务，问题巨多&hellip;ㅠㅠ)
有位同事(韩国人)跟我说，看到了一些不太正常的请求。
希望我帮他和相关负责人沟通。(我是朝鲜族，有时候会帮他们沟通)。
在沟通的过程当中，我感觉到这是一个很有趣的问题。
◆ 为什么会有这么多的请求？ 先简单的说一下业务吧。
线上(天猫商城)出售一笔商品，线下的卖场会把这个单子抢过来，自行给购物者发货。
全国各地的卖场会积极的抢线上出售过的单子，因为每抢到一笔单子，他们就有提成赚。
所以比较勤奋的卖场人员只要店里没有顾客的话就会不停的刷单。
(不停的给服务器发Request请求，看看有没有可抢的单子。)
有些喜欢思考的人就会问，那不能做成推单吗？
这样就没有这种查询的压力了。为什么不那么做的种种原因这里就不做解释了。
那问题是什么呢？其实就是请求量异常的的多。
在我们不怎么注意的情况下，Request请求量1个月内翻了6倍！
不可能吧？当时是9~10月份。又不是双11，又不是做了什么活动&hellip;
卖场数量没什么太多的变化，这请求数量怎么会上升的这么快？
◆ 原来是有人用脚本刷单啊？ 我们赶紧查看了一下日志，发现有几个卖场的请求比较异常。
1个卖场1天内请求量居然达到了10万次。
1秒一次也是刷20个小时也只能刷7.2万次。10万次太夸张了吧？
而且我们在前端做了限制3秒才能刷一次。
问题应该明确了，这几家卖场肯定是在用脚本刷单。
而且是有写计算机基础的人获取后台api的url刷单。
◆ 好像不对？日志证明不了有人用脚本刷单 但是我们看了前一天的日志，傻眼了。
请求量最高的卖场不停的变。
这就不能证明这些卖场人员是用脚本刷单了。
用脚本刷单的卖场，应该是每天都会刷单吧？ 而且请求量最高的卖场分布在全国各地区，
今天是这家卖场，明天又是另一家卖场&hellip;.ㅠㅠ
我们开始怀疑我们的程序有问题了。
前端是不是有bug在特定的情况下会不停的发请求?
企业微信是不是有我们不知道的bug? (我的的应用是嵌套到企业微信的。) 开始争辩:
项目的负责人说我们的程序绝不会有这样的问题。
我们反问你怎么证明你的程序是没问题？
如果是企业微信的问题，我们怎么证明这是企业微信的问题？
◆ 虽然不知道怎么办，但是我们可以做一些改变 争论一番后，大家都累了。不知道怎么解决这件事情。
大家你看我，我看你~ 都等着别人出方案&hellip;^^;;
这怎么办啊？联系了卖场，卖场负责人说我们这里没有异常~ 也不承认自己用了什么脚本。
(这举动很傻，如果我是卖场人员，即使用了我也不会承认自己用了脚本刷单。)
这时候我们发现这个api没有做身份验证。我们提议要不要做身份验证？
(至于为什么不做身份验证，好不专业之类的评价我不做解释了~)
这是一个比较古老的api，而且过些日子会有新的api代替他的。
所以相关的负责人是不怎么希望动这套代码。
而且做身份验证是解决不了这个古怪的现象的。
最后我们决定加身份验证看看，当时大部分的人都认为做身份验证没什么用。
没事找事，这老代码改动后，万一报错怎么办？
虽然我们不知道有什么效果，或是给我们带来什么？
总比什么都不做强吧？
◆ 加了身份验证没什么效果啊？ 添加身份验证功能以后，早上我们紧急发布了新版本。
看了日志，我们失算了~ 没效果&hellip;ㅠㅠ
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/do_change/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  <hr/>
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/linux_command/">linux 常用命令整理(一)</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-09-02T07:28:49&#43;08:00">
          Sep 2, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    这么晚了才认识了linux系统。感觉越来越喜欢linux系统了。
废话少说，这几天自己做的笔记，炫耀一下&hellip;.^^
方便以后用的时候查找。
 命令行 备注   pwd: 改变目录 cd..   ls: 列出目录内容 ls -l = ll  ls -l t 时间排序 S 大小排序 -d 目录  ls -lt --reverse  ls -F 所有文件  Ls -i 查看所有节点inodemv    file: 确定文件类型   less: 查看文件内容   cp: 复制文件和目录 -a 复制所有文件一起权限 -r 递归复制 -u 复制没有或更新的内容  cp file1 file2 dir1 复制文件file1和file2 到dir1   mv: 移动或重命名文件夹和目录 -i 操作需要做确认 -u -v 显示信息  mv file1 file2 file1移动到file2 或重命名file2  mv file1 file2 dir1 将file1,file2 移动到dir1 前提是dir1必须存在   mkdir: 创建目录   rm: 移除文件盒目录 危险的命令，先用ls 看看是不是你要删除的文件，在换成rm执行。  -i 需要确认删除 -r 递归删除 -f --force 忽略提示全部删除 -v 查看信息  rm -rf file1 dir1 删除 file1和dir2 并且不提示执行删除   ln: 创建硬链接和符号链接  in file link 创建硬链接  in -s item link 创建符号链接，这里item可以是目录   通配符 g* g开头的任意文件  b*.
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/linux_command/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  <hr/>
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/solid/">solid原则简单笔记</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-09-01T07:28:49&#43;08:00">
          Sep 1, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    这些天因为工作上的需求，一套代码部署到不同的环境里。
虽然说是一样的业务，但是在不同的环境里难免会有一些少许不同的业务。
刚开始的时候觉得没什么问题，分了几个分支。
但是后来感觉越来越不对劲了，不同的环境分不同的分支，以为是很简单的事情。
时间长了，分支之间的差异也越来越大，感觉应该分不同的仓库。
这分了仓库问题又来了，改了Bug需要再不同的仓库里重复的修改代码，审查代码，合并代码，测试&hellip;
把我忙的不亦乐乎。
这让我怀疑，是不是代码结构本身有问题？
虽然现在用的Go语言不是面向对象编程语言，
但是我觉得经典的面向对象编程思想应该能对我有帮助。
查到了一个很有趣的原则：solid原则。
当做自己的笔记简单的整理了一下solid原则。
SRP	The Single Responsibility Principle	单一责任原则 OCP	The Open Closed Principle	开放封闭原则 LSP	The Liskov Substitution Principle	里氏替换原则 ISP	The Interface Segregation Principle	接口分离原则 DIP	The Dependency Inversion Principle	依赖倒置原则  ◆ 单一责任原则(The Single Responsibility Principle)
一个类只完成它应该完成的职责。  这一原则其实项目刚开始的时候很容易遵守。
但是项目久了后，你会发现你的项目越来越变味儿。
需要不断的重构中，维持单一责任原则。
◆ 开放封闭原则(The Open Closed Principle)
软件实体(类,模块,函数等等)应当对扩展开放，对修改闭合。  好难好难。
尤其是api的版本不断的升级，老版本的api又不能弃用的时候，
而且结构在不断的变化的时候&hellip;ㅠㅠ
◆ 里氏替换原则(The Liskov Substitution Principle)
只有在确定是 is-a 的关系时才能使用继承。  这一原则我刚开始的时候还真不理解。其实很简单。
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/solid/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  <hr/>
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/git_cherry_pick/">git命令 cherry-pick 的使用简介</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-07-30T07:28:49&#43;08:00">
          Jul 30, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    上一篇文章介绍了merge和rebase的用法以及原理。
git命令merge和rebase的简单应用
这里简单的介绍一下 cherry-pick 的用法。
什么时候会用到 cherry-pick 命令？
代码分几个大分支，各自有不同的功能在开发，这时候我们就有这样的需求。
只合并某个分支上的某次修改commit到指定的分支上。
这时候就可以使用cherry-pick命令来操作。
$ git cherry-pick commit_id //想合并的commit_id  图片备用地址
如果是图1这样使用cherry-pick命令的话，
会有 a1, a2, a3 的合并项，在代码中需要删除 a1, a2 再次提交解决冲突才行。
喜欢找茬的人会这么问：这么一来和merge有什么区别吗？
merge的话也不是把 a1, a2, a3 的代码合并过来吗？
merge合并后把 a1, a2 删掉的话跟cherry-pick有什么区别？
区别在于日志。
$ git cherry-pick fd4e09c(a3的 commit_id) error: could not apply fd4e09c... add a3 hint: after resolving the conflicts, mark the corrected paths hint: with 'git add &lt;paths&gt;' or 'git rm &lt;paths&gt;' hint: and commit the result with 'git commit' //.
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/git_cherry_pick/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  <hr/>
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/git_merge_rebase/">git命令merge和rebase的简单应用</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-07-29T07:28:49&#43;08:00">
          Jul 29, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    因为工作的需求，项目分了几个大分支管理了。
不同的环境需要的功能也不一样，在不同的分支里修改。
虽然我不太喜欢这种做法。但是借此机会对merge和rebase, cherry-pick命令研究了一些。 (我比较倾向，有一个主分支，发布在不同的环境是应该由不同的配置和适当的继承来实现。
如果这么做实在太麻烦的话，应该另分出一个仓库repository管理。)
以下是我简单整理的内容。
◆ merge merge就是合并不同分支的代码。
先举个简单的使用场景例子。
从master分支分出一个dev分支开发。
期间我们master分支有 m1,m2,m3 的提交记录。
dev分支有 d1,d2 的提交记录。
2个分支需要合并代码。
$ git merge dev --在master分支把dev分支的代码合并过来。  把2支分支合并，有冲突，解决冲突后需要提交一次合并代码记录。
(为了简单，下图是没有冲突时的场景。)
图片备用地址
◆ rebase rebase其实就是重置代码历史，手动的修改提交记录和代码。
一般项目当中有两种用法。
1. 合并记录
这是一般开发者处理完Issue后，给主分支发出合并请求了。
但是CodeReview的时候发现有不合适的代码，或是有个小Bug需要修改。
修改后又出现一个提交记录，1个Issue有2个提交记录，看着不舒服。
这时候用以下方式处理。
$ git rebase -i HEAD~2 --2代表要修改最近2个记录  图片备用地址
2. 调整顺序
git merge语法是按照时间顺序合并代码的。
图1所示merge是时间的顺序来合并代码的。
master: m1 -&gt; m2 -&gt; m3 dev: d1 -&gt; d2 ==&gt; -- 合并的代码记录是按照时间的排序 master: m1 -&gt; d1 -&gt; m2 -&gt; d2 -&gt; m3  当开发到 m2 的时候我们发布了一个版本，合并了d1,d2后发布出现问题了。
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/git_merge_rebase/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  <hr/>
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/redis/">Redis简单应用</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-07-01T07:28:49&#43;08:00">
          Jul 1, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    这些天因为项目性能上的问题，采用了Redis缓存。
做了一些简单的笔记。
◆ Redis
Redis(REmote DIctionary Server)是一个key-value存储系统。
它支持存储的value类型很多，包括string、list、set、hash等等&hellip;
我最喜欢用 key-json字符。
◆ 应用
用的也简单，代码逻辑中读取相应的信息的时候先去Redis读取，
没有数据，再去数据库(mysql)读取。保存到Redis后，返回结果集。
因为Redis的数据是保存在内存里的(分保存的方式，暂且可以理解成保存在内存)，
所以查询速度会很快。
◆ 缺点
也很容易看到他的缺点，
1. 一致性问题。 为了高效查询性能，付出的代价是数据的一致性。
2. 而且内存的资源是有限的，所以要控制数据量的大小。
◆ 如何去解决的？
如果没有太高的一致性需求的话，
可以直接设置比较短的缓存时间来解决一致性的问题。
比方说缓存时间设置为5分钟，5分钟后数据无效，那再次去数据库查询。
要么做定时任务，每隔一段时间做数据同步。
如果数据一致性需求很高，
建议每次数据有变动代码里需要添加删除Redis数据的逻辑。
(万一这数据的Mapping关系比较复杂的话，光是删掉这些有关系的数据也会让你哭死&hellip;)
只要删掉了，下次查询会从新去数据库查询数据。

我这只是简单应用，没什么深度，哈~ 下面简单的整理了一下语法 1. 安装Redis (我比较喜欢下docker镜像安装，如果不想这么做可以搜一下&hellip;^^)
$ docker run --name test-redis -p 33201:6379 -d redis:latest   &mdash;name 后面的是docker容器名 -p 32xxx:6379 这里需要注意 32xxx 是你链接redis的时候的Port。 -d redis:latest 是你的镜像标签和版本  2. 在shell中访问redis
$ redis-cli -h 127.0.0.1 -p 33201 //链接redis 127.
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/redis/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  <hr/>
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/blockchain_2/">区块链blockchain基础入门(二)</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-06-22T07:28:49&#43;08:00">
          Jun 22, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    上一篇文章简单的介绍了一下区块链blockchain到底是什么。
区块链blockchain零基础入门(一)
接下来继续简单的介绍一下区块链blockchain的结构。
◆ 区块Block + 链Chain 区块链blockchain是由一个个区块block组成，每次交易的数据是写入到一个区块block中。
每个区块是由区块头Heather和去块体Body组成。
区块头Heather: 包含着生成时间，区块体Body的地址(Hash值)，以及上一个区块block的地址(Hash值)。 区块体Body: 详细的数据。  下图是简单的结构
图片备用地址 实际的Header的结构是这样的，不是IT行业的话可以略过下图。
图片备用地址 如上图所示，每个区块Block都保存前一个区块Block的地址(Hash值)。
这样我们就可以把每个区块block连接到上一个区块Block，组成很长的链chain。
这就是区块链blockchain名字的由来。
◆ 节点node 区块链blockchain中的数据是分布式存储。
这些数据会分布在不同的地方存储，存储数据的每一个点我们叫它为节点node。
(仅仅是在区块链blockchain中是可以这么理解)。
以比特币为例(比特币是第一个成功的区块链blockchain技术)。
比特币网络是由很多个节点node组成，而且每个节点node都保存所有的交易数据。
(这会导致很多的重复数据，我感觉这是一种浪费。哈~ )  打个比方，每个节点node都拥有同样的账本。
当某一个节点node增加新的交易数据(新的区块block)。
它会把这份交易数据(新的区块block)分发给各各节点node，
其他节点node收到账本的新一页(新的区块block)后，
把这份交易数据(新的区块block)放在自己账本(整个交易数据)的最后一页。
这样确保所有的节点node的账本是一致的。==&gt; (分布式存储)
图片备用地址 ◆ 挖矿mining 那万一2个以上的节点node同时创建新的区块block岂不是乱了吗？
这里牵扯到区块认证。比特币是大约10分钟一次创建新的区块block。
在这10分钟内的交易数据是以工作量证明(PoW)Proof-Of-Work方式，获得新建区块block权利。
什么意思？不太明白？
简单的说想要在区块链blockchain中添加新的区块block的话，
你需要要获得创建新区块Block的权利。
怎么获取添加新建区块block的权利呢？ 算一道题。 什么样的题？ 可以理解成一个猜数字游戏。1到10000中有一个数据是正确的让你去猜。 怎么办？没办法，只能暴力破解。 是不是5000？ 不是! 是不是5301？ 不是! 是不是xxx ？ 不是！ 是不是xxx ？。。。  这题猜中的偶然性很高，也有运气的成分。
但是如果你的服务器性能好的话，猜的次数越多，猜对的可能性也变得高。
猜对了，获得权利。你可以创建新的区块block，分发到网络。
大声告诉大家: “这道题我猜对了，我已经新建了一个区块block了，你们不用再算了。”
然后把自己建好的区块block分发给其他的节点node。
难度系数difficulty
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/blockchain_2/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  <hr/>
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/blockchain_introduction/">区块链blockchain零基础入门(一)</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-06-22T07:28:49&#43;08:00">
          Jun 22, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    区块链blockchain这几年比较火爆的词。
不是计算机行业的人如何去理解这么技术呢？
我简单的整理了一下，适合完全没有基础的人去看&hellip;^^
区块链blockchain到底是什么？
是一个软件吗？是一个服务吗？ 或是一个网站？
其实用一句话来说他是去中心化，分布式存储数据的技术方案。
还是不明白吗？
如果第一次接触这个概念，不明白是正常，明白了才奇怪呢&hellip;^^
我们先模拟一下A在tao宝里买B的衣服。
1. A ===下订单，付款===&gt; tao宝 2. B ===查看订单===&gt; tao宝 3. B ===发货===&gt; A 4. A 收到物品 5. A ===收货确认===&gt; tao宝 6. tao宝 ===扣除手续费，转账===&gt; B  这个过程当中，tao宝起到了一个中介的作用。
所有的信息通讯是通过它来完成的，中间还赚取手续费。
这里有2个问题需要思考。
1. tao宝把这笔交易记录删了，A如何证明自己从B那里买了衣服(假设衣服是次品想退货)？ 2. 能不能A直接给B付款，B直接给A发货？ 这样是不是省了手续费？  如果没有这个tao宝当中介会怎么样呢？ 问题就来了
1. 没有了中介，A给B付款后，B死赖账怎么办？ 2. 这交易记录存在哪里？  ◆ 那如何做到去中心化，又保障安全呢？
其实很简单, A观察到旁边有C,D,E。
A向大家喊：
A给B付款了，大家都听到了吗？  C,D,E是听到了， 但是出了问题人家会挺身而出给你作证吗？
于是A会这么喊：
A给B付款了，`谁帮我记录一下，我会给辛苦费的`。出问题麻烦您帮我作证。  D听到了这句话后，赶紧做记录。
然后把做好记录的账本给每个人都发一份。
这样D的任务就完成了，可以获得辛苦费了。
这样A和B没有通过tao宝，安全的完成了这笔交易了。 ==&gt; 去中心化
而且D做完记录后，把那些账本给每个人都分发了一份。 ==&gt; 分布式存储
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/blockchain_introduction/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  <hr/>
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/encrpytion_key/">公钥，私钥，数字签名，数字证书的相互关系</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-06-07T07:28:49&#43;08:00">
          Jun 7, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    我们经常听到数字证书，数字签名这些词。
这些证书，签名到底是什么？
他们又起到什么样的作用？ 其原理是什么？
了解这些我们需要先了解加密方式，以及什么是公钥？什么是私钥？
1. 加密方式 先解释一下2种常用的加密方式。
◆ 对称加密
加密的传统方法是对称加密。发出讯息者用一把钥匙对讯息加密。
接收讯息者需用这把钥匙将加密了的讯息解密。
这把钥匙必须以一种其他人没有机会得到它的方式给予接收讯息者。
如果其他人得到了这把钥匙，这种加密方式就没用了。
◆ 非对称加密算法
非对称加密算法需要两个密钥：公开密钥(publickey)和私有密钥(privatekey)
公开密钥与私有密钥是一对，可以相互加密和解密。
如果用公钥对数据进行加密，只有用对应的密钥才能解密。
如果用密钥对数据进行加密，那么只有用对应的公钥才能解密。
因为非对称加密算法安全性比较高，所以下面的数字签名，数字证书都是用了非对称加密算法。

2. 数字签名digital signature 在现实生活中，签名是为了表示这是签名者写的。计算机中，数字签名也是相同的含义。
举一个例子如果A，B两台计算机相互通讯：
A计算机传输给B计算机信息的时候，A计算机会在消息的最后写上去自己的签名，以代表这些信息是A计算机的。 B计算机接到消息后，先看签名是不是A计算机判断不是别人冒充A计算机发送不安全或是无效的信息(有效性)。 除此之外，数字签名还能证明消息传输过程中没有被篡改(完整性)。
◆ 原理
简单的说的话其实就是：
A计算机给B计算机传输信息的时候，
A计算机在信息后面加自己的签名(字符串)，用自己的私钥(privatekey)加密。
B计算机接到数据后，用A计算机的公钥(publickey)解密，确认来源是不是A计算机。
这样确保了完整性，而且A计算机也不可抵赖
(因为用A计算机公钥解密的信息只能是A计算机的私钥加密的信息)

3. 数字证书 先预想一个场景，如果有10台计算机，10台计算机需要记住相互之间的公钥(publickey)，
那有100台计算机，1000台呢？ 他们之间都需要记住相互的公钥吗？
答案肯定是不能，那如何解决这些问题呢？
其实很简单，有个第三方中介机构。记住了这些1000台的公钥相对应的资料。
这种机构称为认证机构(Certification Authority， CA)。
CA开一个证明这是计算机A的信息，发给B计算机。
B计算机通过CA的证明，可以确认这是A计算机的信息。
◆ 如何生成证书？
A计算机将自己的【公钥A】给CA
CA用自己的【私钥CA】给【公钥A】加密，生成【数字签名A】
CA把【公钥A】，【数字签名A】，附加一些【A计算机的信息】整合在一起，生成证书，发给A计算机。
◆ 如何验证证书？
A计算机发信息给B计算机的时候，会附加【数字签名A】
B计算机通过CA的公钥解密【数字签名A】，既可以确认这是A计算机发的信息。
(其实详细原理不是这样，是解证书得到哈希值，通过算法比较这个哈希值的。)

总结 两台计算机相互通讯的时候，为了确保有效性和完整性。需要签名证明是自己(数字签名)。
这签名不能随便公开，所以需要加密。
加密的时候使用的是非对称加密算法。(公钥，私钥)
相互通讯的计算机多了后，需要一个中介公司来证明这个签名是合法的(数字证书)。
这中介机构叫(Certification Authority， CA)。
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/encrpytion_key/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  <hr/>
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/my_go_test3/">Go项目的测试代码3（测试替身Test Double）</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-05-27T20:38:02&#43;08:00">
          May 27, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    上一篇文章介绍了项目中测试代码的写法。
Go项目的测试代码2（项目运用）
这里简单的共享一下测试替身。
当我们写测试代码的时候，经常遇到一个问题。
跟别的模块或服务有依赖性，可是功能还没开发完。
或是因为各种原因(安全，白名单，内网等等&hellip;)开发环境里无法调用相应的模块。
这时候我们应该如何去写测试代码？
因此测试替身Test Double出现了。 其功能和名字一样，做替身。
测试替身Test Double的分以下类型。 Dummy, Stub, Fake, Spy, Mock
Dummy 最简单、最原始的测试替身型别。Dummy 没有实作，最常用于需要参数值但不使用它的情况。
Null 可视为是 Dummy，但真的 Dummy 是接口或基类的衍生，且完全不包含实作。
Stub Dummy 的上一级，Stub 是接口或基类的最低限度实作。
会传回 Void 的方法通常完全不包含实作，而会传回值的方法通常会传回硬式编码的值。
Spy 测试 Spy 类似 Stub，但除了提供客户端可叫用成员的实例，
Spy 还会记录叫用了哪些成员，好让单元测试验证所叫用的成员是否符合预期。
Fake Fake 包含更复杂的实作，通常涉及所继承型别之不同成员之间的互动。
虽然不是完整的生产实作，但 Fake 与生产实作很相似，尽管它会采取一些快捷方式。
Mock Mock 是由 Mock 链接库动态建立 (其他通常是由测试开发人员使用程序代码来产生)。
测试开发人员永远看不到实作接口或基类的实际程序代码，但是可以设定 Mock 以提供传回值、预期要叫用的特定成员&hellip;等等。
视其中的设定而定，Mock 的行为可能会像 Dummy、Stub 或 Spy。
上面是网上流行的概念和理论。
我在项目中的运用 我开发的是在企业微信中的应用，所以需要调用企业微信的API，
用过的人应该知道，这需要登记可信域名(简单的说本地不能调用，只能发布到服务器才能调用)。
也可以用第三方工具去模拟调试，但是这么做感觉很不方便。而且Debug也相当麻烦。
我是这么处理的。
项目初期(一阶段) 直接写硬代码hardcode。
一般我们都会说尽量避免写硬代码hardcode,
但是项目初期我建议大家这么写。
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/my_go_test3/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  <hr/>
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/my_go_test1/">Go项目的测试代码2（项目运用）</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-05-27T20:37:02&#43;08:00">
          May 27, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    上一篇文章介绍了最基本的测试代码的写法。
Go项目的测试代码（基础）
这里简单的共享一下我在项目中使用的方式。
项目结构 我们实际项目中, 结构简单地分了controller和model
 因为现在都已微服务的形式开发，没必要太复杂的结构。
分controller和model已经能满足我们的需求，不需要再细分了。
 |___config ||==&gt; 配置文件 | |___config.qa.go | |___config.production.go ... ... |___controllers ||==&gt; controller，只做参数的有效性和简单的逻辑处理 | |___app_api_test.go | |___app_api.go | |___init_test.go | |___tenant_api.go ... ... |___models ||==&gt; model，所有的业务都是在这里实现的 | |___app.go | |___app_test.go | |___init_test.go | |___tenant.go ... ... |___main.go ||==&gt; 系统的入口 |___factory ||| |___kit ||| ==&gt; 按需求自定义建立一个package方便使用 |___filters ||| ... ...   看项目结构的话，可以发现测试方法直接写在对应的package里面。
有些人喜欢把测试方法分另一个package里写，也可以~ 不同人有不同的喜好。 我也试过这种方式，但是还是喜欢写在同一个package里面，这么写简单方便。
 controllers和models的不同方式 controllers
controller是提供接口api的直接入口，所以那些重要的api都需要写测试方法。
我喜欢在这里写参数验证，业务验证等等主要功能的测试。
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/my_go_test1/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  <hr/>
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/my_go_test/">Go项目的测试代码1（基础）</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-05-27T20:36:02&#43;08:00">
          May 27, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    最近写了测试代码，整理了一下。
先看看简单的测试代码
// add_test.go ==&gt; 文件名 _test.go 结尾的默认为测试代码文件 package models import ( &quot;testing&quot; ) //Test开头的默认为测试方法 func TestAdd(t *testing.T) { //arrange var x, y, res int x = 2 y = 3 //act result = Add(x, y) //assert if result != 5 { t.Fatal(&quot;Add的结果不正确&quot;) } }  // add.go package models func Add(x, y int) int { return x + y }  查看测试结构。
$ go test -v ==&gt; 依次运行当前package的 _test.
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/my_go_test/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  <hr/>
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/docker_mysql/">使用docker运行mysql</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-03-27T07:28:49&#43;08:00">
          Mar 27, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    以前开发的时候都是用本地的sqlite开发，但是极少数情况下，sqlite支持的语法发布到服务器上链接mysql会报错。
为了避免这种现象，还是链接本地mysql开发还是更稳定的， 可是开发的项目多了后，本地的mysql库看起来好乱。 而且有很多项目是实验性的项目，没有及时处理的话会产生很多垃圾数据。
要不使用docker运行mysql，开发结束后把容器删掉 ?  前提是需要准备测试数据脚本，开发或测试的时候随时可以删除，添加数据。 这样就不会因为删除docker容器，重新添加数据而烦恼。 做测试数据很麻烦~ 但是写测试代码，这些测试数据脚本也是必要的。  废话有点多了，说说如何去做。来点干货&hellip;^^
1. 安装docker (建议上官网下载安装包安装。)
$ brew install docker  2. 下载mysql镜像
$ docker pull mysql  3. 启动mysql实例
$ docker run --name mingxie-mysql -p 32xxx:3306 -e MYSQL_ROOT_PASSWORD=1234 -d mysql:latest   &mdash;name 后面的是docker容器名 -p 32xxx:3306 这里需要注意 32xxx 是你链接mysql的时候的Port。 -e MYSQL_ROOT_PASSWORD 是设置mysql的root账号密码 -d mysql 是你的镜像标签  4. 在shell中访问mysql
docker exec -it mingxie-mysql bash root@7c289aa0ca95:/# mysql -uroot -p -h localhost Enter password:  输入密码即可。
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/docker_mysql/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  <hr/>
  <article>
  <header>
    <h2><a href="https://limingxie.github.io/limingxie/hugo_create/">用hugo搭建个人博客</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2018-03-14T10:14:08&#43;08:00">
          Mar 14, 2018
        </time>
      </div>
    </div>
  </header>
  <div>
    这几天研究了用hugo搭建个人博客。
简单的整理了一下。
1.安装hugo（windows 请查看官网介绍 https://gohugo.io/getting-started/installing/）
$ brew install hugo  之后检查版本
$ hugo version Hugo Static Site Generator v0.37.1 darwin/amd64 BuildDate:  2.创建hugo 项目
$ hugo new site my-blog Congratulations! Your new Hugo site is created in /Users/limingxie/Projects/my-blog. Just a few more steps and you're ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/, or create your own with the &quot;hugo new theme &lt;THEMENAME&gt;&quot; command.
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://limingxie.github.io/limingxie/hugo_create/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
</section>
  </main>
  <footer class="container global-footer">
    <div class="copyright-note pull-left">
      limingxie - blog
    </div>
    <div class="sns-links hidden-print">
  
  <a href="mailto:li_mingxie@163.com">
    <i class="fa fa-envelope"></i>
  </a>
  
  
  
  
  
  
  
  
  
  
  
  
</div>

  </footer>

  <script src="https://limingxie.github.io/js/highlight.pack.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
  
  
</body>
</html>



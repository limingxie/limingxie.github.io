<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javas on li_mingxie - Blog</title>
    <link>https://limingxie.github.io/java/</link>
    <description>Recent content in Javas on li_mingxie - Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>limingxie - blog</copyright>
    <lastBuildDate>Sun, 26 Jul 2020 12:28:49 +0800</lastBuildDate>
    
	<atom:link href="https://limingxie.github.io/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>【java笔记】this和super简介</title>
      <link>https://limingxie.github.io/java/this_super/</link>
      <pubDate>Sun, 26 Jul 2020 12:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/java/this_super/</guid>
      <description>本来是确认构造函数的运行方式的。
结果看到继承以及super关键字了&amp;hellip;^^;;
都说this是类似于指自己的一个指针，super是更像一个关键字。
可能我的了解不是那么深入，觉得this就是指自己super就是指父类。其余没感觉到什么特别。
而且感觉前期了解这些就可以了，后面对Java有更深层次的了解后继续在研究~
下面是我简单的试一试，做个记录&amp;hellip;^^
 1.this指向自己。
2.super指向父类。
3.多层继承时，super指向离自己最近的上一层父类。
4.不能同时继承类和接口，也不能同时继承抽象类和接口。
5.构造函数中使用this或super时，必须写在第一行。而且不能同时使用。
 我先创建了以下文件。
图片备用地址
先看看每个文件的代码
【Animal】一个普通的类和函数。
package supertest.animal; public class Animal { // 姓名属性，和子类的值不一样 protected String name = &amp;quot;animalName&amp;quot;; // 无参构造函数 public Animal() { System.out.println(&amp;quot;Animal: There are no parameters&amp;quot;); } // 有参构造函数 public Animal(String str) { System.out.println(&amp;quot;parameters:&amp;quot; + str); } // 父类的函数，子类会重写这个函数 public void run(String str) { System.out.println(str+ &amp;quot;:&amp;quot; + Animal.class); } }  【Horse】子类继承了Animal父类
package supertest.MammalInt; import supertest.animal.Animal; public class Horse extends Animal { // 姓名属性，和父类的值不一样 protected String name = &amp;quot;horseName&amp;quot;; // 无参构造函数 public Horse() { // 这里执行父类有参的构造函数 super(&amp;quot;super has parameters&amp;quot;); System.</description>
    </item>
    
    <item>
      <title>【java笔记】类, 抽象类, 接口的简单实验</title>
      <link>https://limingxie.github.io/java/abstract_test/</link>
      <pubDate>Sun, 26 Jul 2020 07:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/java/abstract_test/</guid>
      <description>要接触，抽象，继承，多态，封装的java了。
为了加深理解自己做了一个简单的实验。
 1.类只能继承一个。
2.抽象类也只能继承一个。
3.接口可以继承多个。
4.不能同时继承类和接口，也不能同时继承抽象类和接口。
 我先创建了以下文件。 图片备用地址
先看看每个文件的代码
【AnimalAbstract】抽象类里添加了2个函数，其中一个是抽象函数。
package animals.animal; public abstract class AnimalAbstract { public void eat(String name){ System.out.println(&amp;quot;eat:&amp;quot; + AnimalAbstract.class + &amp;quot; | name:&amp;quot; + name); }; public abstract void sleep(String name); }  【AnimalClass】一个普通的类和函数。
package animals.animal; public class AnimalClass { public void smile(String name){ System.out.println(&amp;quot;smile:&amp;quot; + AnimalAbstract.class + &amp;quot; | name:&amp;quot; + name); }; }  【AnimalClass】两个不同的接口。
package animals.animal; public interface AnimalInterfaceJump { public void jump (String name); }  package animals.</description>
    </item>
    
    <item>
      <title>【java笔记】序列化和反序列化</title>
      <link>https://limingxie.github.io/java/serialization/</link>
      <pubDate>Thu, 02 Jul 2020 07:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/java/serialization/</guid>
      <description>当做笔记简单了记录了一下。
1. 序列化和反序列化是什么？ 序列化(serializable):
把对象转化为可传输的字节序列过程称为序列化。  反序列化(deserialization):
把字节序列还原为对象的过程称为反序列化。  我觉得网上的这个比喻做的很恰当
 如果我们要把一栋房子从一个地方运输到另一个地方去，
序列化就是我把房子拆成一个个的砖块放到车子里，
然后留下一张房子原来结构的图纸，
反序列化就是我们把房子运输到了目的地以后，
根据图纸把一块块砖头还原成房子原来面目的过程。
 2. 什么时候会用到序列化？ 需要进行跨平台存储和网络传输的数据，都需要进行序列化。
对象的序列化主要有两种用途： 1） 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中； 2） 在网络上传送对象的字节序列。  3. 序列化版本 在序列化过程中，可以使用序列化对象中的serialVersionUID字段做版本控制。
一个对象数据，在反序列化过程中，序列化串中的serialVersionUID与当前对象值不同，反序列化会失败。
4. java实现序列化 java 实现序列化有两种方式。
1.实现Serializable 接口。 2.实现Externalizable 接口(它是Serializable接口的子类)  下面是用Serializable接口实现的简单例子:
import java.io.Serializable; public class Person implements Serializable{ // 如果不指定，JDK工具会自动生成对应的版本号， // 序列化和反序列化的版本号不一样，则反序列化会失败。 private final static long serialVersionUID = 123456789L; // 年龄 private int age; // 名字 private String name ; // 体重，Transient 属性不会被序列化 private transient int weight; public int getAge() { return age; } public void setAge(int age) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://limingxie.github.io/java/encapsulation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://limingxie.github.io/java/encapsulation/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://limingxie.github.io/java/inheritance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://limingxie.github.io/java/inheritance/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://limingxie.github.io/java/polymorphism/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://limingxie.github.io/java/polymorphism/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
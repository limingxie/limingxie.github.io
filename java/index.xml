<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javas on li_mingxie - Blog</title>
    <link>https://limingxie.github.io/java/</link>
    <description>Recent content in Javas on li_mingxie - Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>limingxie - blog</copyright>
    <lastBuildDate>Thu, 02 Jul 2020 07:28:49 +0800</lastBuildDate>
    
	<atom:link href="https://limingxie.github.io/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>【java笔记】序列化和反序列化</title>
      <link>https://limingxie.github.io/java/serialization/</link>
      <pubDate>Thu, 02 Jul 2020 07:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/java/serialization/</guid>
      <description>当做笔记简单了记录了一下。
1. 序列化和反序列化是什么？ 序列化(serializable):
把对象转化为可传输的字节序列过程称为序列化。  反序列化(deserialization):
把字节序列还原为对象的过程称为反序列化。  我觉得网上的这个比喻做的很恰当
 如果我们要把一栋房子从一个地方运输到另一个地方去，
序列化就是我把房子拆成一个个的砖块放到车子里，
然后留下一张房子原来结构的图纸，
反序列化就是我们把房子运输到了目的地以后，
根据图纸把一块块砖头还原成房子原来面目的过程。
 2. 什么时候会用到序列化？ 需要进行跨平台存储和网络传输的数据，都需要进行序列化。
对象的序列化主要有两种用途： 1） 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中； 2） 在网络上传送对象的字节序列。  3. 序列化版本 在序列化过程中，可以使用序列化对象中的serialVersionUID字段做版本控制。
一个对象数据，在反序列化过程中，序列化串中的serialVersionUID与当前对象值不同，反序列化会失败。
4. java实现序列化 java 实现序列化有两种方式。
1.实现Serializable 接口。 2.实现Externalizable 接口(它是Serializable接口的子类)  下面是用Serializable接口实现的简单例子:
import java.io.Serializable; public class Person implements Serializable{ // 如果不指定，JDK工具会自动生成对应的版本号， // 序列化和反序列化的版本号不一样，则反序列化会失败。 private final static long serialVersionUID = 123456789L; // 年龄 private int age; // 名字 private String name ; // 体重，Transient 属性不会被序列化 private transient int weight; public int getAge() { return age; } public void setAge(int age) { this.</description>
    </item>
    
    <item>
      <title>【java笔记】类, 抽象类, 接口的简单试验</title>
      <link>https://limingxie.github.io/java/abstract_test/</link>
      <pubDate>Thu, 02 Jul 2020 07:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/java/abstract_test/</guid>
      <description>从新又要接触，抽象，继承，多态，封装的java了。
为了加深理解自己做了一个简单的实验。
简单的说需要满足一下条件。
 1.类只能继承一个。
2.抽象类也只能继承一个。
3.接口可以继承多个。
4.不能同时继承类和接口，也不能同时继承抽象类和接口。
 我先创建了以下文件。 图片备用地址
先看看每个文件的代码
【AnimalAbstract】抽象类里添加了2个函数，其中一个是抽象函数。
package animals.animal; public abstract class AnimalAbstract { public void eat(String name){ System.out.println(&amp;quot;eat:&amp;quot; + AnimalAbstract.class + &amp;quot; | name:&amp;quot; + name); }; public abstract void sleep(String name); }  【AnimalClass】一个普通的类和函数。
package animals.animal; public class AnimalClass { public void smile(String name){ System.out.println(&amp;quot;smile:&amp;quot; + AnimalAbstract.class + &amp;quot; | name:&amp;quot; + name); }; }  【AnimalClass】两个不同的接口。
package animals.animal; public interface AnimalInterfaceJump { public void jump (String name); }  package animals.</description>
    </item>
    
  </channel>
</rss>
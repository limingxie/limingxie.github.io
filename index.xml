<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>li_mingxie - Blog</title>
    <link>https://limingxie.github.io/</link>
    <description>Recent content on li_mingxie - Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>limingxie - blog</copyright>
    <lastBuildDate>Fri, 30 Oct 2020 08:28:49 +0800</lastBuildDate>
    
	<atom:link href="https://limingxie.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>C语言的编译和执行过程</title>
      <link>https://limingxie.github.io/java/compile_c/</link>
      <pubDate>Fri, 30 Oct 2020 08:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/java/compile_c/</guid>
      <description>没有系统的学过C语言，为了了解java编译流程。
先简单的略过了一下C语言的编译过程。
C语言在Linux系统下编译是有4个过程  预处理Pre-processing 编译Compilation 汇编Assemble 链接Linking  如下图所示每个过程会生成不同的文件。
这些文件会被RAM读取loading后，在系统中运行。
图片备用地址
1.预处理Pre-processing 简单的说预处理就是处理#开头的命令。
 删除注释: 去掉没必要的注释。 宏定义指令: 如#difine, #undef。(替换这些值) 头文件包含指令: 如#include。(直接插入include的代码) 条件编译指令: 如#ifdef，#ifndef，#else，#elif，#endif等。 特殊符号: 如在源程序中出现的#line标识将被解释为当前行号。  下面简单的写代码看一下过程。
#include &amp;lt;stdio.h&amp;gt; #define A 10 #define B 20 int main(){ int a=A; int b=B; int c=a+b; printf(&amp;quot;%d + %d = %d\n&amp;quot;,a,b,c); }  创建first.i文件
$ gcc -E first.c -o first.i  查看一下first.i内容
$ cat first.i # 1 &amp;quot;first.c&amp;quot; # 1 &amp;quot;&amp;lt;built-in&amp;gt;&amp;quot; 1 .</description>
    </item>
    
    <item>
      <title>JVM的内存结构</title>
      <link>https://limingxie.github.io/java/jvm/</link>
      <pubDate>Wed, 28 Oct 2020 08:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/java/jvm/</guid>
      <description>图片备用地址
图片备用地址
图片来源: https://docs.oracle.com/javase/8/docs/index.html
图片备用地址
JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。 引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。
Java虚拟机有自己完善的硬件架构，如处理器、堆栈等，还具有相应的指令系统。 Java虚拟机本质上就是一个程序，当它在命令行上启动的时候，就开始执行保存在某字节码文件中的指令。Java语言的可移植性正是建立在Java虚拟机的基础上。任何平台只要装有针对于该平台的Java虚拟机，字节码文件（.class）就可以在该平台上运行。这就是“一次编译，多次运行”。 Java虚拟机不仅是一种跨平台的软件，而且是一种新的网络计算平台。该平台包括许多相关的技术，如符合开放接口标准的各种API、优化技术等。Java技术使同一种应用可以运行在不同的平台上。Java平台可分为两部分，即Java虚拟机（Java virtual machine，JVM）和Java API类库。
Java堆（Heap） 对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。
Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。
根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。
如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。
方法区（Method Area） 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。
对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。
Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。
根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。
方法区有时被称为持久代（PermGen）。
所有的对象在实例化后的整个运行周期内，都被存放在堆内存中。堆内存又被划分成不同的部分：伊甸区(Eden)，幸存者区域(Survivor Sapce)，老年代（Old Generation Space）。
方法的执行都是伴随着线程的。原始类型的本地变量以及引用都存放在线程栈中。而引用关联的对象比如String，都存在在堆中。为了更好的理解上面这段话，我们可以看一个例子：
这段程序的数据在内存中的存放如下：
通过JConsole工具可以查看运行中的Java程序（比如Eclipse）的一些信息：堆内存的分配，线程的数量以及加载的类的个数；
程序计数器（Program Counter Register） 程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。
如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。
此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
JVM栈（JVM Stacks） 与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。
其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。
在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。
本地方法栈（Native Method Stacks） 本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。
欢迎大家的意见和交流
email: li_mingxie@163.com</description>
    </item>
    
    <item>
      <title>JDK, JRE, JVM简介</title>
      <link>https://limingxie.github.io/java/java_plateform_se_8/</link>
      <pubDate>Mon, 26 Oct 2020 08:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/java/java_plateform_se_8/</guid>
      <description>刚接触到java后，我经常听到的JDK，JRE，JVM这些缩写词。
对我这个java菜鸟来说有时候会没来得及反应过来..^^;;
借助这次机会好好地整理和明确一下这些概念。
Description of Java Conceptual Diagram Oracle提供两个Java平台标准版(Java SE)8的产品:
Java SE开发工具包(JDK)8 和 Java SE运行时环境(JRE)8。
他两的区别是什么？
先看一下官方提供的结构图，看这个图大部分的结构会看的很清楚的。
(下面的解释是不是多余的了? ^^!!)
图片备用地址
图片来源: https://docs.oracle.com/javase/8/docs/index.html
1. JDK（Java Development Kit，Java开发工具包） JDK包含了java所有的内容，包含了JRE和JVM。
比JRE包含了更多的是开发需要的的工具，比如javac，javadoc等等&amp;hellip;
2. JRE（Java Runtime Environment， Java运行环境） 是Java平台，所有的程序需要要在JRE(运行环境)下才能够运行。
包括JVM和Java核心类库和支持文件。
因为是运行环境，所以比起JDK少了那些开发工具。
3. JVM（Java Virtual Machine， Java虚拟机） 无论JDK和JRE都包含着JVM。
因为java编译后的字节码是通过JVM和运行环境的操作系统做互动的。
Java可以跨平台也是因为Java程序和操作系统中间夹着这个JVM。
不同的操作系统会有不同的JVM映射规则，完成跨平台性。
4. JDK, JRE, JVM的相互关系 我们开发系统的时候需要安装JDK, 因为JDK包含着开发需要的开发工具。
开发完成之后的运行环境(正式服务器)就不需要JDK了，只有安装JRE即可。
开发完成的代码编译成字节码以后，通过JVM和真实操作系统互动。
欢迎大家的意见和交流
email: li_mingxie@163.com</description>
    </item>
    
    <item>
      <title>java中的栈内存, 堆内存</title>
      <link>https://limingxie.github.io/java/java_stack_heap/</link>
      <pubDate>Tue, 13 Oct 2020 12:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/java/java_stack_heap/</guid>
      <description>上一篇文章简单整理了栈(stack), 堆(heap), 队列(queue)的结构
这一篇继续整理java中的 占内存，堆内存。
Java把内存划分成两种：一种是栈内存，一种是堆内存。
这里需要解释一下, 这里的堆内存是跟数据结构的堆是完全两码事。
一、栈内存 存放基本类型的变量，以及对象的引用值和函数主体，遵循先入后出的原则。
栈内存在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。
当在一段代码块定义一个变量时:
Java在栈中为变量分配内存空间，当超过变量的作用在域后， Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。  Java中的代码是在函数体中执行的，每个函数主体都会被放在栈内存中，
举例子有一个main()函数。 main()函数里调用了save()函数，那么栈低存储的是main()函数其上面是save()函数。 等save()函数执行后，先销毁save()函数，再销毁main()函数。   栈的优势是，栈内存与堆内存相比是非常小的，存取速度比堆要快，栈数据可以共享。
但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。
 二、堆内存 给我的感觉是所有的引用类型的值是存在堆内存中，地址(指针)是存在栈内存中。
堆内存是区别于栈区、全局数据区和代码区的另一个内存区域。
堆内存在程序运行中，可以动态的调整申请大小。
堆内存的分配过程 当接收到程序的内存申请时: 1. 先游遍操作系统中的记录空闲内存地址的链表，寻找第一个复合大小的节点。 2. 分配给程序该节点的空间，内存空间中的首地址会记录本次分配的大小，为删除的时能正确的获取长度。 3. 把该节点从操作系统的空闲节点中删除。  找到的堆节点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。
堆内存的大小受限于计算机系统中有效的虚拟内存。所以堆内存获得的空间比较灵活，也比较大。
但是也是因为这些原因容易产生内存碎片，存取速度也比较慢。
三、内存回收 `栈内存`变量基本上用完就回收了。 `堆内存`中: 数组和对象等引用类型在没有变量指向它的时候才被视为垃圾。 在随后的一个`不确定的时间`被垃圾回收器释放掉。 因为这些原因回收内存之前会一直占用资源, 也不知道这些资源什么会回收释放。  四、其他数据存储 1、常量池：存放基本类型常量和字符串常量
2、静态域(static)：存放静态成员(static定义的)编译的时候直接分配空间。要求程序代码中不允许有可变数据结构(比如可变数组)的存在。
3、非RAM存储：硬盘等永久存储空间
五、编译时分配的空间 最后我们再次已编译的角度去理解静态, 栈, 堆的存储方式。
1. 静态存储分配:
编译的时候直接分配空间, 所以会要求程序代码中不允许有可变数据结构(比如可变数组)的存在。
2. 栈存储分配:
是编译的时候时未知的, 但是运行中进入一个程序模块时,必须知道该程序模块所需的数据区大小才能够为其分配内存。
3. 堆存储分配:
是编译的时候时未知的, 运行时模块入口处都无法确定存储要求 数据结构的内存分配, 执行的过程也是可变的。所以存取速度也比较慢。</description>
    </item>
    
    <item>
      <title>栈(stack), 堆(heap), 队列(queue) 是什么？</title>
      <link>https://limingxie.github.io/basic/stack/</link>
      <pubDate>Mon, 12 Oct 2020 23:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/basic/stack/</guid>
      <description>我们平时经常遇到栈(stack), 队列(queue), 堆(heap)这些词语。
像我这样不是计算机专业毕业的程序原来说，为了更好的理解这些内容，
我自己简单的整理了一下栈(stack), 堆(heap)和队列(queue)的概念。
希望有些帮助。
 栈(stack), 队列(queue), 堆(heap)都是一个数据结构。
 一. 栈(stack) 是计算机科学里最重要且最基础的数据结构之一。 (直接看下图更容易理解)
1.常用的几个名词 栈顶(top), 栈底(bottom), 进栈(push), 出栈(pop)。 栈中的每个元素称为一个frame。  2.一个很重要的特点 先进后出: FILO（First In Last Out）的原则存储数据。  它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶,
需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。
图片备用地址
3.最经典的计算机应用是函数调用 每个进程都会有一个栈，每个frame中记录了调用函数的参数，自动变量和返回地址。
当该函数调用一个新的函数时，栈中会 push一个frame。
当函数执行完毕返回时，该frame会pop，从而进入调用该函数的原函数，继续执行。
4.比较常用的应用场景 1) 子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中， 直到子程序执行完后再将地址取出，以回到原来的程序中。 2) 递归的调用：可以用来在函数调用的时候存储断点， 储存下一个指令的地址外，也将参数、区域变量等数据存入栈中。 3) 表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。 4) 二叉树的遍历。 5) 图形的深度优先(depth一first)搜索法。  二. 堆(heap) 堆(Heap)是计算机科学中的一种特别的完全二叉树。(直接看下图更容易理解)
维基百科是这么解释的:
若是满足以下特性，即可称为堆： “给定堆中任意节点P和C，若P是C的父节点，那么P的值会小于等于（或大于等于）C的值”。 若父节点的值恒小于等于子节点的值，此堆称为最小堆(min heap); 反之，若父节点的值恒大于等于子节点的值，此堆称为最大堆(max heap)。 在堆中最顶端的那一个节点，称作根节点（root node），根节点本身没有父节点(parent node)  堆总是满足下列性质：
 堆中某个节点的值总是不大于或不小于其父节点的值</description>
    </item>
    
    <item>
      <title>简单整理java的编译流程？</title>
      <link>https://limingxie.github.io/java/nio/</link>
      <pubDate>Mon, 28 Sep 2020 08:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/java/nio/</guid>
      <description>如图所示, 先是由 javac 命令把 .java 文件编译成 .class文件。
.class是可以加载到JVM中运行。当类文件在JVM加载过程中通常会被处理和修改。 转换后的 .class 文件通过解释器解析成可执行代码。 最后由JIT编译器编译成机器码。
图片备用地址
先大致的了解一下，等有时间在详细整理。 同步、异步、阻塞、非阻塞都是和IO（输入输出）有关的概念。最简单的文件读取就是IO操作。而在文件读取这件事儿上，可以有多种方式。
IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。 在计算机科学中指计算机之间或人与计算机之间的信息交换。比如两台计算机通过网卡进行交互，比如向硬盘写入数据或读取硬盘数据，比如人敲击鼠标键盘等，都是I/O。具体的参见上面的详细说明。 狭义上是读写硬盘的操作。广义上只要不需要cpu参与的都是io操作。
I/O（英语：Input/Output），即输入／输出，通常指数据在存储器（内部和外部）或其他周边设备之间的输入和输出，是信息处理系统（例如计算机）与外部世界（可能是人类或另一信息处理系统）之间的通信。输入是系统接收的信号或数据，输出则是从其发送的信号或数据。该术语也可以用作行动的一部分；到“运行I/O”是运行输入或输出的操作。
由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。举个例子来说，比如要把100M的数据写入磁盘，CPU输出100M的数据只需要0.01秒，可是磁盘要接收这100M数据可能需要10秒，怎么办呢？有两种办法：
第一种是CPU等着，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为同步IO；
另一种方法是CPU不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为异步IO。
Java中的三种IO模型 在Java语言中，一共提供了三种IO模型，分别是阻塞IO（BIO）、非阻塞IO（NIO）、异步IO（AIO）。这里面的BIO和NIO都是同步的IO模型，即同步阻塞IO和同步非阻塞IO，异步IO指的是异步非阻塞IO。BIO （Blocking I/O）：同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。NIO （New I/O）：同时支持阻塞与非阻塞模式，但主要是使用同步非阻塞IO。AIO （Asynchronous I/O）：异步非阻塞I/O模型。
同步请求，A调用B，B的处理是同步的，在处理完之前他不会通知A，只有处理完之后才会明确的通知A。
异步请求，A调用B，B的处理是异步的，B在接到请求后先告诉A我已经接到请求了，然后异步去处理，处理完之后通过回调等方式再通知A。
那么阻塞（blocking IO）和非阻塞（non-blocking IO）的区别就在于第一个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。
阻塞请求，A调用B，A一直等着B的返回，别的事情什么也不干。
非阻塞请求，A调用B，A不用一直等着B的返回，先去忙别的事情了。
阻塞就是：当某个事件或者任务在执行过程中，它发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足；
非阻塞就是：当某个事件或者任务在执行过程中，它发出一个请求操作，如果该请求操作需要的条件不满足，会立即返回一个标志信息告知条件不满足，不会一直在那等待。
这就是阻塞和非阻塞的区别。也就是说阻塞和非阻塞的区别关键在于 当发出请求一个操作时，如果条件不满足，是会一直等待还是返回一个标志信息。
阻塞和非阻塞指的是执行一个操作是等操作结束再返回，还是马上返回。
比如餐馆的服务员为用户点菜，当有用户点完菜后，服务员将菜单给后台厨师，此时有两种方式：
· 第一种：就在出菜窗口等待，直到厨师炒完菜后将菜送到窗口，然后服务员再将菜送到用户手中；
· 第二种：等一会再到窗口来问厨师，某个菜好了没？如果没有先处理其他事情，等会再去问一次；
第一种就是阻塞方式，第二种则是非阻塞的。
同步和异步又是另外一个概念，它是事件本身的一个属性。还拿前面点菜为例，服务员直接跟厨师打交道，菜出来没出来，服务员直接指导，但只有当厨师将菜送到服务员手上，这个过程才算正常完成，这就是同步的事件。同样是点菜，有些餐馆有专门的传菜人员，当厨师炒好菜后，传菜员将菜送到传菜窗口，并通知服务员，这就变成异步的了。其实异步还可以分为两种：带通知的和不带通知的。前面说的那种属于带通知的。有些传菜员干活可能主动性不是很够，不会主动通知你，你就需要时不时的去关注一下状态。这种就是不带通知的异步。
对于同步的事件，你只能以阻塞的方式去做。而对于异步的事件，阻塞和非阻塞都是可以的。非阻塞又有两种方式：主动查询和被动接收消息。被动不意味着一定不好，在这里它恰恰是效率更高的，因为在主动查询里绝大部分的查询是在做无用功。对于带通知的异步事件，两者皆可。而对于不带通知的，则只能用主动查询。
欢迎大家的意见和交流
email: li_mingxie@163.com</description>
    </item>
    
    <item>
      <title>【java笔记】反射的简单应用</title>
      <link>https://limingxie.github.io/java/reflect/</link>
      <pubDate>Thu, 30 Jul 2020 23:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/java/reflect/</guid>
      <description>今天在代码中看到了invoke方法，了解到原来是使用了反射的机制。
以前没怎么用过这种方式，所以简单的了解一下。
具体内容是简单的写了一套代码。
声明Animal类
import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; class Animal { public Animal() { } public Animal(String name, int age) { this.name = name; this.age = age; } private int age; public String name; public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; }  普通的方法和使用反射</description>
    </item>
    
    <item>
      <title>【java笔记】this和super简介</title>
      <link>https://limingxie.github.io/java/this_super/</link>
      <pubDate>Sun, 26 Jul 2020 12:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/java/this_super/</guid>
      <description>本来是确认构造函数的运行方式的。
结果看到继承以及super关键字了&amp;hellip;^^;;
都说this是类似于指自己的一个指针，super是更像一个关键字。
可能我的了解不是那么深入，觉得this就是指自己super就是指父类。其余没感觉到什么特别。
而且感觉前期了解这些就可以了，后面对Java有更深层次的了解后继续在研究~
下面是我简单的试一试，做个记录&amp;hellip;^^
 1.this指向自己。
2.super指向父类。
3.多层继承时，super指向离自己最近的上一层父类。
4.不能同时继承类和接口，也不能同时继承抽象类和接口。
5.构造函数中使用this或super时，必须写在第一行。而且不能同时使用。
 我先创建了以下文件。
图片备用地址
先看看每个文件的代码
【Animal】一个普通的类和函数。
package supertest.animal; public class Animal { // 姓名属性，和子类的值不一样 protected String name = &amp;quot;animalName&amp;quot;; // 无参构造函数 public Animal() { System.out.println(&amp;quot;Animal: There are no parameters&amp;quot;); } // 有参构造函数 public Animal(String str) { System.out.println(&amp;quot;parameters:&amp;quot; + str); } // 父类的函数，子类会重写这个函数 public void run(String str) { System.out.println(str+ &amp;quot;:&amp;quot; + Animal.class); } }  【Horse】子类继承了Animal父类
package supertest.MammalInt; import supertest.animal.Animal; public class Horse extends Animal { // 姓名属性，和父类的值不一样 protected String name = &amp;quot;horseName&amp;quot;; // 无参构造函数 public Horse() { // 这里执行父类有参的构造函数 super(&amp;quot;super has parameters&amp;quot;); System.</description>
    </item>
    
    <item>
      <title>【java笔记】类, 抽象类, 接口的简单实验</title>
      <link>https://limingxie.github.io/java/abstract_test/</link>
      <pubDate>Sun, 26 Jul 2020 07:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/java/abstract_test/</guid>
      <description>要接触，抽象，继承，多态，封装的java了。
为了加深理解自己做了一个简单的实验。
 1.类只能继承一个。
2.抽象类也只能继承一个。
3.接口可以继承多个。
4.不能同时继承类和接口，也不能同时继承抽象类和接口。
 我先创建了以下文件。 图片备用地址
先看看每个文件的代码
【AnimalAbstract】抽象类里添加了2个函数，其中一个是抽象函数。
package animals.animal; public abstract class AnimalAbstract { public void eat(String name){ System.out.println(&amp;quot;eat:&amp;quot; + AnimalAbstract.class + &amp;quot; | name:&amp;quot; + name); }; public abstract void sleep(String name); }  【AnimalClass】一个普通的类和函数。
package animals.animal; public class AnimalClass { public void smile(String name){ System.out.println(&amp;quot;smile:&amp;quot; + AnimalAbstract.class + &amp;quot; | name:&amp;quot; + name); }; }  【AnimalClass】两个不同的接口。
package animals.animal; public interface AnimalInterfaceJump { public void jump (String name); }  package animals.</description>
    </item>
    
    <item>
      <title>【java笔记】序列化和反序列化</title>
      <link>https://limingxie.github.io/java/serialization/</link>
      <pubDate>Thu, 02 Jul 2020 07:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/java/serialization/</guid>
      <description>当做笔记简单了记录了一下。
1. 序列化和反序列化是什么？ 序列化(serializable):
把对象转化为可传输的字节序列过程称为序列化。  反序列化(deserialization):
把字节序列还原为对象的过程称为反序列化。  我觉得网上的这个比喻做的很恰当
 如果我们要把一栋房子从一个地方运输到另一个地方去，
序列化就是我把房子拆成一个个的砖块放到车子里，
然后留下一张房子原来结构的图纸，
反序列化就是我们把房子运输到了目的地以后，
根据图纸把一块块砖头还原成房子原来面目的过程。
 2. 什么时候会用到序列化？ 需要进行跨平台存储和网络传输的数据，都需要进行序列化。
对象的序列化主要有两种用途： 1） 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中； 2） 在网络上传送对象的字节序列。  3. 序列化版本 在序列化过程中，可以使用序列化对象中的serialVersionUID字段做版本控制。
一个对象数据，在反序列化过程中，序列化串中的serialVersionUID与当前对象值不同，反序列化会失败。
4. java实现序列化 java 实现序列化有两种方式。
1.实现Serializable 接口。 2.实现Externalizable 接口(它是Serializable接口的子类)  下面是用Serializable接口实现的简单例子:
import java.io.Serializable; public class Person implements Serializable{ // 如果不指定，JDK工具会自动生成对应的版本号， // 序列化和反序列化的版本号不一样，则反序列化会失败。 private final static long serialVersionUID = 123456789L; // 年龄 private int age; // 名字 private String name ; // 体重，Transient 属性不会被序列化 private transient int weight; public int getAge() { return age; } public void setAge(int age) { this.</description>
    </item>
    
    <item>
      <title>【k8s】kubernetes基本的概念</title>
      <link>https://limingxie.github.io/k8s/k8s/</link>
      <pubDate>Wed, 01 Jul 2020 07:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/k8s/k8s/</guid>
      <description>最近抽时间了解Kubernetes。那些网上和官方的材料都讲得很深，很细。
我平时也用不上这些技术，不需要知道的这么深这么细，
花这么多少时间去了解，过几天没怎么用还会忘记的&amp;hellip;ㅠㅠ
其实我想知道的是其大致的结构。
下面我是以笔记的形式见得整理了其结构。希望对刚刚接触的人的了解有所帮助。
1.基本概念 ◆ Kubernetes 是什么？
引用官方的解释：
 Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。
Kubernetes 拥有一个庞大且快速增长的生态系统。Kubernetes 的服务、支持和工具广泛可用。
 以我的理解：
Kubernetes(简称k8s)是一个可以操作容器和自动化部署的开源平台。
还不理解？ 没关系~
简单的说手动管理docker container太累，用Kubernetes管理吧~
一个服务器可以有多个docker container，多个服务器形成一个集群。
下面简单的介绍一下Kubernetes集群的结构。
2.Kubernetes集群结构 备用图片
图片来源于:https://kubernetes.io/docs/concepts/overview/components/
备用图片 图片来源于:http://omerio.com/2015/12/18/learn-the-kubernetes-key-concepts-in-10-minutes/
其他结构图： 备用图片1 备用图片2
简单的说：
每个Kubernetes集群都有他自己的master节点。
这里包含着kube-apiserver，kube-controller-manager，kube-scheduler，etcd。
看图和名字可以大致的猜到:
`kube-apiserver`是通讯枢纽。 `kube-controller-manager`是控制器。 `kube-scheduler`是调度器。 `etcd`是键值数据库。  普通的节点包含着kubelet, kube-proxy。
`kubelet`跟master节点通讯。 `kube-proxy`是网络代理。  下面具体的介绍一下比较重要的组件。
3.Kubernetes组件 ◆ Kubernetes Master
每个k8s集群里至少需要一个Master节点来负责整个集群的管理和控制，
所有控制命令都是发给它，它来负责具体的调度和执行。
master节点包含三个进程和一个键值数据库etcd。
三个进程都运行在集群中的某个节点上，主控组件通常这个节点被称为 master 节点。
这些进程包括：kube-apiserver、kube-controller-manager 和 kube-scheduler。
kube-apiserver:
集群内各个功能模块之间数据交互和通信的中心枢纽。 所有从集群到master的通信路径都终止于apiserver。  kube-controller-manager:
通过apiserver监控集群的公共状态，并致力于将当前状态转变为期望的状态。  kube-scheduler:</description>
    </item>
    
    <item>
      <title>递归(recursive)</title>
      <link>https://limingxie.github.io/algorithm/recursive/</link>
      <pubDate>Sat, 03 Aug 2019 07:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/algorithm/recursive/</guid>
      <description>最近在研究算法&amp;hellip;^^ 算法中最基本的是排序。
排序当中最常见的是快速排序(Quick Sort)。
理解快速排序的代码，那就离不开递归了。
递归以前听过，但是真正去了解和研究是最近为了对算法的了解。
 递归感觉很绕？
 但是理解其原理的话还是可以接受的，甚至有时候会喜欢这种方式。
 递归不像传说中的那么麻烦。弄清楚
基线条件（base case）和 递归条件（recursive case）
 绝大多数的递归都是这种结构
function(parameter){ if 基线条件（base case）{ //离开递归的条件，这条件如果不明确，或是满足不了。很容易进入死循环。 return } XXXX...XXXX //处理业务逻辑 if 递归条件（recursive case）{ //进入递归的条件 function(parameter) } }  来看看一个简单的例子吧。详细内容可以看这里
https://pintia.cn/problem-sets/994805260223102976/problems/994805325918486528
卡拉兹(Callatz)猜想： 对任何一个正整数 n，如果它是偶数，那么把它砍掉一半； 如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。 我们假设 n &amp;lt; 1000 输入样例： 3 输出样例： 5  一般情况下我们是直接用while或for循环处理。
#include &amp;lt;stdio.h&amp;gt; int main() { int step = 0; //记录步数 int n = 0; scanf(&amp;quot;%d&amp;quot;, &amp;amp;n); while (n !</description>
    </item>
    
    <item>
      <title>算法(排序)</title>
      <link>https://limingxie.github.io/algorithm/sort/</link>
      <pubDate>Tue, 09 Jul 2019 07:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/algorithm/sort/</guid>
      <description>感觉现在越来越重视算法了。
因为我不是计算机专业的，所以对这些算法没怎么注意过。
这么高领的程序员居然才接触到这些算法，真是惭愧啊&amp;hellip;^^;;
以下代码都是用golang写的，算是给自己看的笔记~
(1) 冒泡排序(Bubble Sort) (2) 选择排序(Selection Sort) (3) 插入排序(Insertion Sort) (4) 希尔排序(Shell Sort) (5) 归并排序(Merge Sort) (6) 快速排序(Quick Sort) (7) 基数排序(Radix Sort) (8) 堆排序(Heap Sort)   ◆ 冒泡排序(Bubble Sort)
图片备用地址
//泡沫排序 func BubbleSort() { data := []int{8, 100, 99, 50, 22, 15, 16, 2, 99, 1000, 999, 1} for i := 0; i &amp;lt; len(data); i++ { for j := 0; j &amp;lt; len(data)-i; j++ { if data[j] &amp;gt; data[j+1] { v := data[j] data[j] = data[j+1] data[j+1] = v } } } fmt.</description>
    </item>
    
    <item>
      <title>设计原则那些事儿</title>
      <link>https://limingxie.github.io/limingxie/solid_1/</link>
      <pubDate>Thu, 06 Jun 2019 07:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/limingxie/solid_1/</guid>
      <description>代码架构的设计原则中最普遍的是solid原则。
SRP	Single Responsibility Principle	单一责任原则 OCP	Open Closed Principle	开放封闭原则 LSP	Liskov Substitution Principle	里氏替换原则 ISP	Interface Segregation Principle	接口分离原则 DIP	Dependency Inversion Principle	依赖反转原则   ◆ SRP:单一责任原则(Single Responsibility Principle)
一个类只完成它应该完成的职责。  任何一个软件模块都应该只对某一类行为者负责。 它的作用就是告诉我们在哪里划清边界。
◆ OCP:开放封闭原则(Open Closed Principle)
软件实体(类,模块,函数等等)应当对扩展开放，对修改闭合。  这其实就是要关注，增加新的功能的时候能不能不修改以前旧代码？
增加新功能，需要大改旧代码，说明没做好开放封闭原则。
◆ LSP:里氏替换原则(Liskov Substitution Principle)
模块之间应能自由替换。  其实就是替换别的模块的时候不应该影响别的模块，导致发生修改事项。
◆ ISP:接口分离原则(Interface Segregation Principle)
如果一个接口包含了过多的方法，应该通过分离接口将其拆分。  如果依赖和自己没有关系或不需要的东西，需要应该把他拆分，只依赖和自己有关系的不分。
◆ DIP:依赖反转原则(Dependency Inversion Principle)
上层(抽象)不应该依赖于下层(实体)，下层(实体)应该依赖于上层(抽象)。  换句话说上层策略性代码不应该依赖底层细节性代码，
底层细节性代码应该依赖上层策略性的代码。
包的内聚性三原則 ◆ REP:复用/发布等同原则(Release Reuse Equivalency Principle)</description>
    </item>
    
    <item>
      <title>Go项目:error错误处理</title>
      <link>https://limingxie.github.io/limingxie/err_return/</link>
      <pubDate>Thu, 14 Feb 2019 08:38:02 +0800</pubDate>
      
      <guid>https://limingxie.github.io/limingxie/err_return/</guid>
      <description>上一篇文章我介绍了拆分服务后如何去写测试代码。
Go项目:傻瓜式联合测试
今天想共享一下，我是如何处理error。
其实error是一个普通的处理。
但是你拆分服务后，一个功能调用多个api来实现的时候，错误处理是一件麻烦的事情。
有A,B,C 3个服务。 A服务提供的一个功能是需要 B和C 服务的信息。 该功能执行的时候出问题，单凭返回的信息，你是很难一眼看出问题点是在哪里。 (go 的错误提示过于简单...^^;;)  所以我自己写了处理error的一个package。
https://github.com/limingxie/taoyuan-kit/blob/master/errs/errs.go 实际运用例子 这是普通的处理方式
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;strconv&amp;quot; ) func main() { value, err := returnValue() if err != nil { //普通的处理 fmt.Println(err) } else { fmt.Println(value) } } func returnValue() (int, error) { value, err := strconv.Atoi(&amp;quot;string&amp;quot;) if err != nil { //普通的处理 return 0, err } return value, nil }  执行结果</description>
    </item>
    
    <item>
      <title>Go项目:傻瓜式联合测试</title>
      <link>https://limingxie.github.io/limingxie/my_go_test4/</link>
      <pubDate>Tue, 12 Feb 2019 08:38:02 +0800</pubDate>
      
      <guid>https://limingxie.github.io/limingxie/my_go_test4/</guid>
      <description>现在微服务很流行，加上我的项目从10个表增加到30+表的业务量。
感觉有些内容不应该在同一个服务里。
于是我做了一个决定: 拆分服务。
分了4个服务后发现每个服务都不到8个表。每个服务的业务复杂度都不高。 心理暗自高兴，都说微服务，微服务，原来这么好？ 这种好心情维持不到半天，后面出的问题让我晕头转向。 踩了N多个坑...ㅠㅠ  今天我想说说其中的测试代码。
当我分了服务后写单元测试，其实没遇到过什么大问题。
可以使用上一篇文章介绍的测试替身。
Go项目的测试代码3（测试替身Test Double）
问题是每个服务的功能是需要调用其他的服务。 `单元测试没问题，不能确保联合调用没问题`。 (初期把单元测试过的代码直接发布运营，把我害惨了...)  我做了所有人都能想到的傻瓜式的联合测试方法。
简单，傻瓜式，但是很实用。 联合测试思路 就是把数据库(我是用mysql)和几个服务用docker容器启动，执行联合测试代码。
这跟本地运行每个服务后，运行测试代码有什么区别吗？(嘿嘿~ 自己想想吧。我也不知道~) 实际运用例子 有点linux和docker基础的人，看下面的脚本应该能想到怎么做的吧？
#deleted container and image, network docker rm -f a-service-api-container b-service-api-container... my-mysql 2&amp;gt; /dev/null docker rmi -f a-service-api-image b-service-api-image ... 2&amp;gt; /dev/null docker network rm my-network 2&amp;gt; /dev/null echo &#39;&#39; echo &#39;&amp;lt;============== start =============&amp;gt;&#39; #create docker network docker network create my-network echo &#39;mysql starting .</description>
    </item>
    
    <item>
      <title>工作中我们常见的误解</title>
      <link>https://limingxie.github.io/limingxie/work_note/</link>
      <pubDate>Sun, 23 Dec 2018 07:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/limingxie/work_note/</guid>
      <description>虽然我不是什么大领导或是一个高管。
但是看那些尤其是不满5年的员工们对工作的误解。
让我感到无法用语言形容的发闷。。。
而且组长的真心建议组员们一般都会有反感，以为组长对自己做“洗脑工作”。
我简单的整理了几个常见的误解。
1. 我的组长是“加班狂”，“工作狂”。 我经常听到这句话： 组长总是加班，害的我不能及时下班。 每次下班的时候，总是要看组长的脸色。  其实组长也是人，他也有家庭。
如果不是自己的公司，任何一个人都不会喜欢加班的！
那他们为什么总是加班呢？
很简单，要么工作还没做完，要么有什么苦恼。
为什么啊？ 你觉得没有更多的事情要做啊？
也很简单。
要么你能力不够，不能把活分给你做。
要么你在组长心目中的地位，连这些苦恼也不够分享。
虽然这句话说的有点偏激。但是你如果不知道上司为什么加班。
是不是要主动的尝试一下去了解或帮忙一起解决问题呢？
2. 我需要私人空间，下班后不要找我。 我从事的工作是IT行业。
有时候系统出问题，找相关负责人解决问题。 经常会听到这样的答复： 我没带有电脑，不太方便确认。 我会(明天)下周一去公司确认的。  这句话说得合情合理。 但是你如果不能及时处理这些事故，公司的损失会不会更大？
你要明白这个道理：
如果你不是24小时待命的状态，公司的核心业务永远不会和你有关系的。
这是让人很不舒服的现实，你准备接受这个现实了吗？
3. 我很努力工作，为什么还没晋升？ 有些人嘴里说很努力工作，但是实际行动却不是。
上班的时间大家都很忙，不忙的是要被开除的人。
我要成为专业技术人员(可是1年连一本技术书籍也不看) 我想成为优秀的领导(可是连公司的目标是什么都不知道) ... ...  真正有目标，有理想的人至少1天会多抽出工作以外的2，3个小时为自己投资。
1周至少抽出10~20个小时，为自己的未来学习。
其实大部分的新员工都只是沉浸在自己的世界里，认为自己很努力。
习惯性的高估自己，其实你不是自己想象中的那么重要，厉害的人。
每个人都有自己的观点，有自己的思想和想法。
如果看了这个文章让你不舒服了，我感到抱歉。
不同意我的观点，可以骂我，当我是一个装逼的傻鸟吧&amp;hellip;^^
欢迎大家的意见和交流
email: li_mingxie@163.com</description>
    </item>
    
    <item>
      <title>go websocket的简单应用</title>
      <link>https://limingxie.github.io/limingxie/go_socket/</link>
      <pubDate>Thu, 06 Dec 2018 07:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/limingxie/go_socket/</guid>
      <description>因为我们是做企业ERP系统，没什么机会接触socket。
这次准备做消息推送才了解到还有socket这种技术&amp;hellip;ㅠㅠ
(做了这么多年的程序员，连这个也不知道&amp;hellip;ㅠㅠ)
具体的概念就不在这里多做解释了，可以百度或谷歌搜一下。
我做了一个简单的demo，以便于了解使用方式。
demo大致构建了如下的场景。
图片备用地址
Dial(用户) package main import ( &amp;quot;log&amp;quot; &amp;quot;golang.org/x/net/websocket&amp;quot; ) func main() { origin := &amp;quot;http://localhost/&amp;quot; url := &amp;quot;ws://localhost:5001/test&amp;quot; //创建websocket链接 ws, err := websocket.Dial(url, &amp;quot;&amp;quot;, origin) if err != nil { log.Fatal(err) } var s string for { //等待websocket的消息(这个过程是bolck) err := websocket.Message.Receive(ws, &amp;amp;s) if err != nil { log.Println(err) ws.Close() break } log.Println(s) } }  
Handle(SocketServer) package main import ( &amp;quot;log&amp;quot; &amp;quot;net/http&amp;quot; &amp;quot;sync&amp;quot; &amp;quot;github.</description>
    </item>
    
    <item>
      <title>我们(开发者)的责任</title>
      <link>https://limingxie.github.io/limingxie/development_responsibility/</link>
      <pubDate>Wed, 14 Nov 2018 05:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/limingxie/development_responsibility/</guid>
      <description>开发者写错的代码发布到运营，出问题了。
谁来承担责任？
◆ 运营发布后出了问题，第一责任人不是我们 经常听到的解释是写代码的开发者不是第一责任人。
第一责任人应该是公司老板，
之后是项目负责人，
之后是QA,
之后是CodeReview的人，
最后才轮到写代码的开发者。
那我们开发者真的没有责任吗？
我们开发者的责任是什么？
◆ 我们不用承担任何的责任吗？ 举一个例子。你跟家人一起在海边度假。 你写的项目出问题了，你的同事解决不了问题。 联系上你了。你会怎么做？ 你会说CodeReview的时候怎么没发现？ QA怎么没发现？... 出了问题让我牺牲个人休假的时间解决问题？  我有女儿，现在上幼儿园。 在幼儿园不小心打哭了别家小朋友。怎么办？ 论责任第一责任当然是幼儿园老师没有看好孩子。 那我就没有一点的责任吗？我不需要做任何的事情吗？ 至少应该像孩子的父母道歉，之后教孩子不要犯同样的错误。  那我写的代码呢？
把自己写的代码看做为自己的孩子，这么高尚的话可能不适合我们。
但是身为成年人，我们都知道自己做错的事情，自己需要承担责任。
其实工作中我不太喜欢责任这个单词
因为追究责任很容易发生相互推卸责任。当发生事故，或是错误的时候，
我们第一反应该是如何去解决这个问题。而不是寻找责任人是谁，谁来背这个黑锅。
◆ 那我们应该怎么做？ 回到上面举得例子。出问题了。
你会放弃你的度假，解决这次问题吗？
还是先拖着尽可能让你的同事帮你解决？ 或是晚上回到宾馆再帮他们处理吗？
我们希望当然是后者，事情不紧急的时候我们完全不需要牺牲你的假期。
但是万一这是十分紧急的事情呢？
很遗憾的告诉你，你不想听的建议：
兄弟，你应该回去处理。因为这才是专业表现
(这里指的当然不是公司，你需要去有电脑，有网的地方解决问题。)
无论你在做什么？ 你要对自己的写的代码负起责任。
因为程序的错误而产生的经济损失，有可能是你的老板去承担。
但是至少你有责任，把有问题的代码修改正确。
什么时候改？ 不紧急，你可以慢慢改。
紧急? 对不起，你得马上处理了。
你的女人在幼儿园打了别的小朋友你不管吗？
你也可以不管，你可以表现的不专业。
之后这件事情会传遍幼儿园。
其他家长远离你，其他孩子远离你的孩子。
◆ 我们需要对自己写的代码负责 哪怕是10年前写代码，如果是你写过的代码。(前提是没有人动过~)
因为你写错的原因出的bug你就有责任去修改它。
(这里不包含新需求的添加，以及环境的变化出现的问题。) 

 是的，我们是开发者。 我们需要负的责任就是我们自己写的代码。  欢迎大家的意见和交流</description>
    </item>
    
    <item>
      <title>一个小小变化的威力</title>
      <link>https://limingxie.github.io/limingxie/do_change/</link>
      <pubDate>Sun, 11 Nov 2018 05:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/limingxie/do_change/</guid>
      <description>今天是双11，本想来公司凑凑热闹&amp;hellip;^^
结果主要问题都是在我的服务里，还把登录给整瘫了半个多小时&amp;hellip;ㅠㅠ
高峰过去了，可以松口气了~ 抽个时间写写博文。
这次我想共享我们公司一个部门遇到的事情。
那天我正在为拆分服务的问题而苦恼着。
(本来是一个的服务拆分成4个服务，问题巨多&amp;hellip;ㅠㅠ)
有位同事(韩国人)跟我说，看到了一些不太正常的请求。
希望我帮他和相关负责人沟通。(我是朝鲜族，有时候会帮他们沟通)。
在沟通的过程当中，我感觉到这是一个很有趣的问题。
◆ 为什么会有这么多的请求？ 先简单的说一下业务吧。
线上(天猫商城)出售一笔商品，线下的卖场会把这个单子抢过来，自行给购物者发货。
全国各地的卖场会积极的抢线上出售过的单子，因为每抢到一笔单子，他们就有提成赚。
所以比较勤奋的卖场人员只要店里没有顾客的话就会不停的刷单。
(不停的给服务器发Request请求，看看有没有可抢的单子。)
有些喜欢思考的人就会问，那不能做成推单吗？
这样就没有这种查询的压力了。为什么不那么做的种种原因这里就不做解释了。
那问题是什么呢？其实就是请求量异常的的多。
在我们不怎么注意的情况下，Request请求量1个月内翻了6倍！
不可能吧？当时是9~10月份。又不是双11，又不是做了什么活动&amp;hellip;
卖场数量没什么太多的变化，这请求数量怎么会上升的这么快？
◆ 原来是有人用脚本刷单啊？ 我们赶紧查看了一下日志，发现有几个卖场的请求比较异常。
1个卖场1天内请求量居然达到了10万次。
1秒一次也是刷20个小时也只能刷7.2万次。10万次太夸张了吧？
而且我们在前端做了限制3秒才能刷一次。
问题应该明确了，这几家卖场肯定是在用脚本刷单。
而且是有写计算机基础的人获取后台api的url刷单。
◆ 好像不对？日志证明不了有人用脚本刷单 但是我们看了前一天的日志，傻眼了。
请求量最高的卖场不停的变。
这就不能证明这些卖场人员是用脚本刷单了。
用脚本刷单的卖场，应该是每天都会刷单吧？ 而且请求量最高的卖场分布在全国各地区，
今天是这家卖场，明天又是另一家卖场&amp;hellip;.ㅠㅠ
我们开始怀疑我们的程序有问题了。
前端是不是有bug在特定的情况下会不停的发请求?
企业微信是不是有我们不知道的bug? (我的的应用是嵌套到企业微信的。) 开始争辩:
项目的负责人说我们的程序绝不会有这样的问题。
我们反问你怎么证明你的程序是没问题？
如果是企业微信的问题，我们怎么证明这是企业微信的问题？
◆ 虽然不知道怎么办，但是我们可以做一些改变 争论一番后，大家都累了。不知道怎么解决这件事情。
大家你看我，我看你~ 都等着别人出方案&amp;hellip;^^;;
这怎么办啊？联系了卖场，卖场负责人说我们这里没有异常~ 也不承认自己用了什么脚本。
(这举动很傻，如果我是卖场人员，即使用了我也不会承认自己用了脚本刷单。)
这时候我们发现这个api没有做身份验证。我们提议要不要做身份验证？
(至于为什么不做身份验证，好不专业之类的评价我不做解释了~)
这是一个比较古老的api，而且过些日子会有新的api代替他的。
所以相关的负责人是不怎么希望动这套代码。
而且做身份验证是解决不了这个古怪的现象的。
最后我们决定加身份验证看看，当时大部分的人都认为做身份验证没什么用。
没事找事，这老代码改动后，万一报错怎么办？
虽然我们不知道有什么效果，或是给我们带来什么？
总比什么都不做强吧？
◆ 加了身份验证没什么效果啊？ 添加身份验证功能以后，早上我们紧急发布了新版本。
看了日志，我们失算了~ 没效果&amp;hellip;ㅠㅠ</description>
    </item>
    
    <item>
      <title>技术Leader需要哪些能力？</title>
      <link>https://limingxie.github.io/work_sharing/share_001/</link>
      <pubDate>Mon, 24 Sep 2018 07:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/work_sharing/share_001/</guid>
      <description>身为一个高龄开发者(30岁以上应该都属于高领开发者吧？ 这世道&amp;hellip;ㅠㅠ)，
我也一样(35岁&amp;hellip;ㅠㅠ)，对以后的职业发展有很多苦恼。
我是幸运的，因为我们公司有一位高龄的技术牛人。
让我看到了一丝希望。原来做技术也可以做到这种程度。
(写了好几本书，开源代码社区的CodeReviewer，我问的问题没有一个回答不了的。)
前些天有幸和这位牛人做了一些工作上的交流，
如何做好技术Leader，让我感触特别的深刻。
以下是他给我的建议以及我自己的感触，想和大家一起分享。
快速的转换思维的能力 我们写代码的时候不喜欢被打扰，谁也不喜欢自己聚精会神的工作的时候有人过来打扰自己。
但是大部分的情况下，我们不是单打独斗。
身为技术Leader，我们就有义务去协助组员。
当我们有一定的能力以后，甚至需要协助几个小组或全公司的技术。
在这种情况下，如果拒绝被打扰，等于是不想做这个技术Leader。
我们需要学会`快速的进入角色`，进入时间越短越好。 一般情况下，别人做一些复杂的开发的时候需要5~10分钟去`从新进入状态`的话， 我们要在1分钟内，甚至30秒内要进入状态。 哪怕是自己的开发，或是其他人问题的解答。`必须快速的进入状态去解决问题。` A过来问，解答后我们用5分钟的时间调整状态做自己的事情，刚准备好B过来了。 等把B的问题看完后，再用5分钟的时间调节自己的状态，过了不到10分钟，C又过来问.... 等着晚上加班做自己的事情吧...^^||  所以快速的转换思维进入状态能力很重要，需要有意的去提高这个能力才行。
细分工作的能力 身为技术Leader现在准备好随时被打扰了吗？
随时被打扰，我们的工作就不做了吗？
所以我们还需要细分工作，分的颗粒度越小越好。
我一般喜欢这种编程方式。 觉得这是一个比较复杂的内容，&#39;就直接写个空的方法。先返回null。&#39; 走下一个逻辑。`先把这个流程或是这个逻辑走完。` 之后再写刚才觉得复杂的那个方法。 这么写话，每个函数所实现的内容不多，中间被打断也是很容易从新进入状态。 也可以先让问问题的人等几分钟，先把这个逻辑写完后，再一起讨论他的问题。  所以提高细分工作的能力会让不断的打扰中，保持工作的节奏和状态。
不断的摸索提高自己的开发效率的方法 不断的被打扰，不断的开会。
让技术Leader们很难有充分的时间去编程。
那技术Leader就不需要写代码吗？
或是写很少一部分的代码就可以了吗？
其实不是，为了保持自己对技术感觉，我们还需要不断的写代码。
那怎么办？
这会要求我们别人写2个小时的内容，我么是要在1小时甚至半小时内写完。
需要不断的去找合适自己，提高自己效率的方法。 举例子，合理的运用快捷键。command + ~ , command + -&amp;gt;... git的gcb, ga, gcmsg, ggpull, ggpush, glum, glog ... vsCode的多行修改， opton + 方向键，control + -&amp;gt; ... 合理的分配屏幕的结构，左边数据库，中间代码窗，下面zsh窗，右边postman等等... 我们需要不断思考，寻找对自己合适的开发方式。 还有最重要的一项&#39;提高整体的技术能力以及思维能力。&#39;  不断的摸索提高自己的开发效率的方法，学会短时间内出满意的产出物。</description>
    </item>
    
    <item>
      <title>linux 常用命令整理(一)</title>
      <link>https://limingxie.github.io/limingxie/linux_command/</link>
      <pubDate>Sun, 02 Sep 2018 07:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/limingxie/linux_command/</guid>
      <description>这么晚了才认识了linux系统。感觉越来越喜欢linux系统了。
废话少说，这几天自己做的笔记，炫耀一下&amp;hellip;.^^
方便以后用的时候查找。
 命令行 备注   pwd: 改变目录 cd..   ls: 列出目录内容 ls -l = ll  ls -l t 时间排序 S 大小排序 -d 目录  ls -lt --reverse  ls -F 所有文件  Ls -i 查看所有节点inodemv    file: 确定文件类型   less: 查看文件内容   cp: 复制文件和目录 -a 复制所有文件一起权限 -r 递归复制 -u 复制没有或更新的内容  cp file1 file2 dir1 复制文件file1和file2 到dir1   mv: 移动或重命名文件夹和目录 -i 操作需要做确认 -u -v 显示信息  mv file1 file2 file1移动到file2 或重命名file2  mv file1 file2 dir1 将file1,file2 移动到dir1 前提是dir1必须存在   mkdir: 创建目录   rm: 移除文件盒目录 危险的命令，先用ls 看看是不是你要删除的文件，在换成rm执行。  -i 需要确认删除 -r 递归删除 -f --force 忽略提示全部删除 -v 查看信息  rm -rf file1 dir1 删除 file1和dir2 并且不提示执行删除   ln: 创建硬链接和符号链接  in file link 创建硬链接  in -s item link 创建符号链接，这里item可以是目录   通配符 g* g开头的任意文件  b*.</description>
    </item>
    
    <item>
      <title>solid原则简单笔记</title>
      <link>https://limingxie.github.io/limingxie/solid/</link>
      <pubDate>Sat, 01 Sep 2018 07:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/limingxie/solid/</guid>
      <description>这些天因为工作上的需求，一套代码部署到不同的环境里。
虽然说是一样的业务，但是在不同的环境里难免会有一些少许不同的业务。
刚开始的时候觉得没什么问题，分了几个分支。
但是后来感觉越来越不对劲了，不同的环境分不同的分支，以为是很简单的事情。
时间长了，分支之间的差异也越来越大，感觉应该分不同的仓库。
这分了仓库问题又来了，改了Bug需要再不同的仓库里重复的修改代码，审查代码，合并代码，测试&amp;hellip;
把我忙的不亦乐乎。
这让我怀疑，是不是代码结构本身有问题？
虽然现在用的Go语言不是面向对象编程语言，
但是我觉得经典的面向对象编程思想应该能对我有帮助。
查到了一个很有趣的原则：solid原则。
当做自己的笔记简单的整理了一下solid原则。
SRP	The Single Responsibility Principle	单一责任原则 OCP	The Open Closed Principle	开放封闭原则 LSP	The Liskov Substitution Principle	里氏替换原则 ISP	The Interface Segregation Principle	接口分离原则 DIP	The Dependency Inversion Principle	依赖倒置原则  ◆ 单一责任原则(The Single Responsibility Principle)
一个类只完成它应该完成的职责。  这一原则其实项目刚开始的时候很容易遵守。
但是项目久了后，你会发现你的项目越来越变味儿。
需要不断的重构中，维持单一责任原则。
◆ 开放封闭原则(The Open Closed Principle)
软件实体(类,模块,函数等等)应当对扩展开放，对修改闭合。  好难好难。
尤其是api的版本不断的升级，老版本的api又不能弃用的时候，
而且结构在不断的变化的时候&amp;hellip;ㅠㅠ
◆ 里氏替换原则(The Liskov Substitution Principle)
只有在确定是 is-a 的关系时才能使用继承。  这一原则我刚开始的时候还真不理解。其实很简单。</description>
    </item>
    
    <item>
      <title>git命令 cherry-pick 的使用简介</title>
      <link>https://limingxie.github.io/limingxie/git_cherry_pick/</link>
      <pubDate>Mon, 30 Jul 2018 07:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/limingxie/git_cherry_pick/</guid>
      <description>上一篇文章介绍了merge和rebase的用法以及原理。
git命令merge和rebase的简单应用
这里简单的介绍一下 cherry-pick 的用法。
什么时候会用到 cherry-pick 命令？
代码分几个大分支，各自有不同的功能在开发，这时候我们就有这样的需求。
只合并某个分支上的某次修改commit到指定的分支上。
这时候就可以使用cherry-pick命令来操作。
$ git cherry-pick commit_id //想合并的commit_id  图片备用地址
如果是图1这样使用cherry-pick命令的话，
会有 a1, a2, a3 的合并项，在代码中需要删除 a1, a2 再次提交解决冲突才行。
喜欢找茬的人会这么问：这么一来和merge有什么区别吗？
merge的话也不是把 a1, a2, a3 的代码合并过来吗？
merge合并后把 a1, a2 删掉的话跟cherry-pick有什么区别？
区别在于日志。
$ git cherry-pick fd4e09c(a3的 commit_id) error: could not apply fd4e09c... add a3 hint: after resolving the conflicts, mark the corrected paths hint: with &#39;git add &amp;lt;paths&amp;gt;&#39; or &#39;git rm &amp;lt;paths&amp;gt;&#39; hint: and commit the result with &#39;git commit&#39; //.</description>
    </item>
    
    <item>
      <title>git命令merge和rebase的简单应用</title>
      <link>https://limingxie.github.io/limingxie/git_merge_rebase/</link>
      <pubDate>Sun, 29 Jul 2018 07:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/limingxie/git_merge_rebase/</guid>
      <description>因为工作的需求，项目分了几个大分支管理了。
不同的环境需要的功能也不一样，在不同的分支里修改。
虽然我不太喜欢这种做法。但是借此机会对merge和rebase, cherry-pick命令研究了一些。 (我比较倾向，有一个主分支，发布在不同的环境是应该由不同的配置和适当的继承来实现。
如果这么做实在太麻烦的话，应该另分出一个仓库repository管理。)
以下是我简单整理的内容。
◆ merge merge就是合并不同分支的代码。
先举个简单的使用场景例子。
从master分支分出一个dev分支开发。
期间我们master分支有 m1,m2,m3 的提交记录。
dev分支有 d1,d2 的提交记录。
2个分支需要合并代码。
$ git merge dev --在master分支把dev分支的代码合并过来。  把2支分支合并，有冲突，解决冲突后需要提交一次合并代码记录。
(为了简单，下图是没有冲突时的场景。)
图片备用地址
◆ rebase rebase其实就是重置代码历史，手动的修改提交记录和代码。
一般项目当中有两种用法。
1. 合并记录
这是一般开发者处理完Issue后，给主分支发出合并请求了。
但是CodeReview的时候发现有不合适的代码，或是有个小Bug需要修改。
修改后又出现一个提交记录，1个Issue有2个提交记录，看着不舒服。
这时候用以下方式处理。
$ git rebase -i HEAD~2 --2代表要修改最近2个记录  图片备用地址
2. 调整顺序
git merge语法是按照时间顺序合并代码的。
图1所示merge是时间的顺序来合并代码的。
master: m1 -&amp;gt; m2 -&amp;gt; m3 dev: d1 -&amp;gt; d2 ==&amp;gt; -- 合并的代码记录是按照时间的排序 master: m1 -&amp;gt; d1 -&amp;gt; m2 -&amp;gt; d2 -&amp;gt; m3  当开发到 m2 的时候我们发布了一个版本，合并了d1,d2后发布出现问题了。</description>
    </item>
    
    <item>
      <title>Redis简单应用</title>
      <link>https://limingxie.github.io/limingxie/redis/</link>
      <pubDate>Sun, 01 Jul 2018 07:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/limingxie/redis/</guid>
      <description>这些天因为项目性能上的问题，采用了Redis缓存。
做了一些简单的笔记。
◆ Redis
Redis(REmote DIctionary Server)是一个key-value存储系统。
它支持存储的value类型很多，包括string、list、set、hash等等&amp;hellip;
我最喜欢用 key-json字符。
◆ 应用
用的也简单，代码逻辑中读取相应的信息的时候先去Redis读取，
没有数据，再去数据库(mysql)读取。保存到Redis后，返回结果集。
因为Redis的数据是保存在内存里的(分保存的方式，暂且可以理解成保存在内存)，
所以查询速度会很快。
◆ 缺点
也很容易看到他的缺点，
1. 一致性问题。 为了高效查询性能，付出的代价是数据的一致性。
2. 而且内存的资源是有限的，所以要控制数据量的大小。
◆ 如何去解决的？
如果没有太高的一致性需求的话，
可以直接设置比较短的缓存时间来解决一致性的问题。
比方说缓存时间设置为5分钟，5分钟后数据无效，那再次去数据库查询。
要么做定时任务，每隔一段时间做数据同步。
如果数据一致性需求很高，
建议每次数据有变动代码里需要添加删除Redis数据的逻辑。
(万一这数据的Mapping关系比较复杂的话，光是删掉这些有关系的数据也会让你哭死&amp;hellip;)
只要删掉了，下次查询会从新去数据库查询数据。

我这只是简单应用，没什么深度，哈~ 下面简单的整理了一下语法 1. 安装Redis (我比较喜欢下docker镜像安装，如果不想这么做可以搜一下&amp;hellip;^^)
$ docker run --name test-redis -p 33201:6379 -d redis:latest   &amp;mdash;name 后面的是docker容器名 -p 32xxx:6379 这里需要注意 32xxx 是你链接redis的时候的Port。 -d redis:latest 是你的镜像标签和版本  2. 在shell中访问redis
$ redis-cli -h 127.0.0.1 -p 33201 //链接redis 127.</description>
    </item>
    
    <item>
      <title>区块链blockchain基础入门(二)</title>
      <link>https://limingxie.github.io/limingxie/blockchain_2/</link>
      <pubDate>Fri, 22 Jun 2018 07:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/limingxie/blockchain_2/</guid>
      <description>上一篇文章简单的介绍了一下区块链blockchain到底是什么。
区块链blockchain零基础入门(一)
接下来继续简单的介绍一下区块链blockchain的结构。
◆ 区块Block + 链Chain 区块链blockchain是由一个个区块block组成，每次交易的数据是写入到一个区块block中。
每个区块是由区块头Heather和去块体Body组成。
区块头Heather: 包含着生成时间，区块体Body的地址(Hash值)，以及上一个区块block的地址(Hash值)。 区块体Body: 详细的数据。  下图是简单的结构
图片备用地址 实际的Header的结构是这样的，不是IT行业的话可以略过下图。
图片备用地址 如上图所示，每个区块Block都保存前一个区块Block的地址(Hash值)。
这样我们就可以把每个区块block连接到上一个区块Block，组成很长的链chain。
这就是区块链blockchain名字的由来。
◆ 节点node 区块链blockchain中的数据是分布式存储。
这些数据会分布在不同的地方存储，存储数据的每一个点我们叫它为节点node。
(仅仅是在区块链blockchain中是可以这么理解)。
以比特币为例(比特币是第一个成功的区块链blockchain技术)。
比特币网络是由很多个节点node组成，而且每个节点node都保存所有的交易数据。
(这会导致很多的重复数据，我感觉这是一种浪费。哈~ )  打个比方，每个节点node都拥有同样的账本。
当某一个节点node增加新的交易数据(新的区块block)。
它会把这份交易数据(新的区块block)分发给各各节点node，
其他节点node收到账本的新一页(新的区块block)后，
把这份交易数据(新的区块block)放在自己账本(整个交易数据)的最后一页。
这样确保所有的节点node的账本是一致的。==&amp;gt; (分布式存储)
图片备用地址 ◆ 挖矿mining 那万一2个以上的节点node同时创建新的区块block岂不是乱了吗？
这里牵扯到区块认证。比特币是大约10分钟一次创建新的区块block。
在这10分钟内的交易数据是以工作量证明(PoW)Proof-Of-Work方式，获得新建区块block权利。
什么意思？不太明白？
简单的说想要在区块链blockchain中添加新的区块block的话，
你需要要获得创建新区块Block的权利。
怎么获取添加新建区块block的权利呢？ 算一道题。 什么样的题？ 可以理解成一个猜数字游戏。1到10000中有一个数据是正确的让你去猜。 怎么办？没办法，只能暴力破解。 是不是5000？ 不是! 是不是5301？ 不是! 是不是xxx ？ 不是！ 是不是xxx ？。。。  这题猜中的偶然性很高，也有运气的成分。
但是如果你的服务器性能好的话，猜的次数越多，猜对的可能性也变得高。
猜对了，获得权利。你可以创建新的区块block，分发到网络。
大声告诉大家: “这道题我猜对了，我已经新建了一个区块block了，你们不用再算了。”
然后把自己建好的区块block分发给其他的节点node。
难度系数difficulty</description>
    </item>
    
    <item>
      <title>区块链blockchain零基础入门(一)</title>
      <link>https://limingxie.github.io/limingxie/blockchain_introduction/</link>
      <pubDate>Fri, 22 Jun 2018 07:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/limingxie/blockchain_introduction/</guid>
      <description>区块链blockchain这几年比较火爆的词。
不是计算机行业的人如何去理解这么技术呢？
我简单的整理了一下，适合完全没有基础的人去看&amp;hellip;^^
区块链blockchain到底是什么？
是一个软件吗？是一个服务吗？ 或是一个网站？
其实用一句话来说他是去中心化，分布式存储数据的技术方案。
还是不明白吗？
如果第一次接触这个概念，不明白是正常，明白了才奇怪呢&amp;hellip;^^
我们先模拟一下A在tao宝里买B的衣服。
1. A ===下订单，付款===&amp;gt; tao宝 2. B ===查看订单===&amp;gt; tao宝 3. B ===发货===&amp;gt; A 4. A 收到物品 5. A ===收货确认===&amp;gt; tao宝 6. tao宝 ===扣除手续费，转账===&amp;gt; B  这个过程当中，tao宝起到了一个中介的作用。
所有的信息通讯是通过它来完成的，中间还赚取手续费。
这里有2个问题需要思考。
1. tao宝把这笔交易记录删了，A如何证明自己从B那里买了衣服(假设衣服是次品想退货)？ 2. 能不能A直接给B付款，B直接给A发货？ 这样是不是省了手续费？  如果没有这个tao宝当中介会怎么样呢？ 问题就来了
1. 没有了中介，A给B付款后，B死赖账怎么办？ 2. 这交易记录存在哪里？  ◆ 那如何做到去中心化，又保障安全呢？
其实很简单, A观察到旁边有C,D,E。
A向大家喊：
A给B付款了，大家都听到了吗？  C,D,E是听到了， 但是出了问题人家会挺身而出给你作证吗？
于是A会这么喊：
A给B付款了，`谁帮我记录一下，我会给辛苦费的`。出问题麻烦您帮我作证。  D听到了这句话后，赶紧做记录。
然后把做好记录的账本给每个人都发一份。
这样D的任务就完成了，可以获得辛苦费了。
这样A和B没有通过tao宝，安全的完成了这笔交易了。 ==&amp;gt; 去中心化
而且D做完记录后，把那些账本给每个人都分发了一份。 ==&amp;gt; 分布式存储</description>
    </item>
    
    <item>
      <title>公钥，私钥，数字签名，数字证书的相互关系</title>
      <link>https://limingxie.github.io/limingxie/encrpytion_key/</link>
      <pubDate>Thu, 07 Jun 2018 07:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/limingxie/encrpytion_key/</guid>
      <description>我们经常听到数字证书，数字签名这些词。
这些证书，签名到底是什么？
他们又起到什么样的作用？ 其原理是什么？
了解这些我们需要先了解加密方式，以及什么是公钥？什么是私钥？
1. 加密方式 先解释一下2种常用的加密方式。
◆ 对称加密
加密的传统方法是对称加密。发出讯息者用一把钥匙对讯息加密。
接收讯息者需用这把钥匙将加密了的讯息解密。
这把钥匙必须以一种其他人没有机会得到它的方式给予接收讯息者。
如果其他人得到了这把钥匙，这种加密方式就没用了。
◆ 非对称加密算法
非对称加密算法需要两个密钥：公开密钥(publickey)和私有密钥(privatekey)
公开密钥与私有密钥是一对，可以相互加密和解密。
如果用公钥对数据进行加密，只有用对应的密钥才能解密。
如果用密钥对数据进行加密，那么只有用对应的公钥才能解密。
因为非对称加密算法安全性比较高，所以下面的数字签名，数字证书都是用了非对称加密算法。

2. 数字签名digital signature 在现实生活中，签名是为了表示这是签名者写的。计算机中，数字签名也是相同的含义。
举一个例子如果A，B两台计算机相互通讯：
A计算机传输给B计算机信息的时候，A计算机会在消息的最后写上去自己的签名，以代表这些信息是A计算机的。 B计算机接到消息后，先看签名是不是A计算机判断不是别人冒充A计算机发送不安全或是无效的信息(有效性)。 除此之外，数字签名还能证明消息传输过程中没有被篡改(完整性)。
◆ 原理
简单的说的话其实就是：
A计算机给B计算机传输信息的时候，
A计算机在信息后面加自己的签名(字符串)，用自己的私钥(privatekey)加密。
B计算机接到数据后，用A计算机的公钥(publickey)解密，确认来源是不是A计算机。
这样确保了完整性，而且A计算机也不可抵赖
(因为用A计算机公钥解密的信息只能是A计算机的私钥加密的信息)

3. 数字证书 先预想一个场景，如果有10台计算机，10台计算机需要记住相互之间的公钥(publickey)，
那有100台计算机，1000台呢？ 他们之间都需要记住相互的公钥吗？
答案肯定是不能，那如何解决这些问题呢？
其实很简单，有个第三方中介机构。记住了这些1000台的公钥相对应的资料。
这种机构称为认证机构(Certification Authority， CA)。
CA开一个证明这是计算机A的信息，发给B计算机。
B计算机通过CA的证明，可以确认这是A计算机的信息。
◆ 如何生成证书？
A计算机将自己的【公钥A】给CA
CA用自己的【私钥CA】给【公钥A】加密，生成【数字签名A】
CA把【公钥A】，【数字签名A】，附加一些【A计算机的信息】整合在一起，生成证书，发给A计算机。
◆ 如何验证证书？
A计算机发信息给B计算机的时候，会附加【数字签名A】
B计算机通过CA的公钥解密【数字签名A】，既可以确认这是A计算机发的信息。
(其实详细原理不是这样，是解证书得到哈希值，通过算法比较这个哈希值的。)

总结 两台计算机相互通讯的时候，为了确保有效性和完整性。需要签名证明是自己(数字签名)。
这签名不能随便公开，所以需要加密。
加密的时候使用的是非对称加密算法。(公钥，私钥)
相互通讯的计算机多了后，需要一个中介公司来证明这个签名是合法的(数字证书)。
这中介机构叫(Certification Authority， CA)。</description>
    </item>
    
    <item>
      <title>Go项目的测试代码3（测试替身Test Double）</title>
      <link>https://limingxie.github.io/limingxie/my_go_test3/</link>
      <pubDate>Sun, 27 May 2018 20:38:02 +0800</pubDate>
      
      <guid>https://limingxie.github.io/limingxie/my_go_test3/</guid>
      <description>上一篇文章介绍了项目中测试代码的写法。
Go项目的测试代码2（项目运用）
这里简单的共享一下测试替身。
当我们写测试代码的时候，经常遇到一个问题。
跟别的模块或服务有依赖性，可是功能还没开发完。
或是因为各种原因(安全，白名单，内网等等&amp;hellip;)开发环境里无法调用相应的模块。
这时候我们应该如何去写测试代码？
因此测试替身Test Double出现了。 其功能和名字一样，做替身。
测试替身Test Double的分以下类型。 Dummy, Stub, Fake, Spy, Mock
Dummy 最简单、最原始的测试替身型别。Dummy 没有实作，最常用于需要参数值但不使用它的情况。
Null 可视为是 Dummy，但真的 Dummy 是接口或基类的衍生，且完全不包含实作。
Stub Dummy 的上一级，Stub 是接口或基类的最低限度实作。
会传回 Void 的方法通常完全不包含实作，而会传回值的方法通常会传回硬式编码的值。
Spy 测试 Spy 类似 Stub，但除了提供客户端可叫用成员的实例，
Spy 还会记录叫用了哪些成员，好让单元测试验证所叫用的成员是否符合预期。
Fake Fake 包含更复杂的实作，通常涉及所继承型别之不同成员之间的互动。
虽然不是完整的生产实作，但 Fake 与生产实作很相似，尽管它会采取一些快捷方式。
Mock Mock 是由 Mock 链接库动态建立 (其他通常是由测试开发人员使用程序代码来产生)。
测试开发人员永远看不到实作接口或基类的实际程序代码，但是可以设定 Mock 以提供传回值、预期要叫用的特定成员&amp;hellip;等等。
视其中的设定而定，Mock 的行为可能会像 Dummy、Stub 或 Spy。
上面是网上流行的概念和理论。
我在项目中的运用 我开发的是在企业微信中的应用，所以需要调用企业微信的API，
用过的人应该知道，这需要登记可信域名(简单的说本地不能调用，只能发布到服务器才能调用)。
也可以用第三方工具去模拟调试，但是这么做感觉很不方便。而且Debug也相当麻烦。
我是这么处理的。
项目初期(一阶段) 直接写硬代码hardcode。
一般我们都会说尽量避免写硬代码hardcode,
但是项目初期我建议大家这么写。</description>
    </item>
    
    <item>
      <title>Go项目的测试代码2（项目运用）</title>
      <link>https://limingxie.github.io/limingxie/my_go_test1/</link>
      <pubDate>Sun, 27 May 2018 20:37:02 +0800</pubDate>
      
      <guid>https://limingxie.github.io/limingxie/my_go_test1/</guid>
      <description>上一篇文章介绍了最基本的测试代码的写法。
Go项目的测试代码（基础）
这里简单的共享一下我在项目中使用的方式。
项目结构 我们实际项目中, 结构简单地分了controller和model
 因为现在都已微服务的形式开发，没必要太复杂的结构。
分controller和model已经能满足我们的需求，不需要再细分了。
 |___config ||==&amp;gt; 配置文件 | |___config.qa.go | |___config.production.go ... ... |___controllers ||==&amp;gt; controller，只做参数的有效性和简单的逻辑处理 | |___app_api_test.go | |___app_api.go | |___init_test.go | |___tenant_api.go ... ... |___models ||==&amp;gt; model，所有的业务都是在这里实现的 | |___app.go | |___app_test.go | |___init_test.go | |___tenant.go ... ... |___main.go ||==&amp;gt; 系统的入口 |___factory ||| |___kit ||| ==&amp;gt; 按需求自定义建立一个package方便使用 |___filters ||| ... ...   看项目结构的话，可以发现测试方法直接写在对应的package里面。
有些人喜欢把测试方法分另一个package里写，也可以~ 不同人有不同的喜好。 我也试过这种方式，但是还是喜欢写在同一个package里面，这么写简单方便。
 controllers和models的不同方式 controllers
controller是提供接口api的直接入口，所以那些重要的api都需要写测试方法。
我喜欢在这里写参数验证，业务验证等等主要功能的测试。</description>
    </item>
    
    <item>
      <title>Go项目的测试代码1（基础）</title>
      <link>https://limingxie.github.io/limingxie/my_go_test/</link>
      <pubDate>Sun, 27 May 2018 20:36:02 +0800</pubDate>
      
      <guid>https://limingxie.github.io/limingxie/my_go_test/</guid>
      <description>最近写了测试代码，整理了一下。
先看看简单的测试代码
// add_test.go ==&amp;gt; 文件名 _test.go 结尾的默认为测试代码文件 package models import ( &amp;quot;testing&amp;quot; ) //Test开头的默认为测试方法 func TestAdd(t *testing.T) { //arrange var x, y, res int x = 2 y = 3 //act result = Add(x, y) //assert if result != 5 { t.Fatal(&amp;quot;Add的结果不正确&amp;quot;) } }  // add.go package models func Add(x, y int) int { return x + y }  查看测试结构。
$ go test -v ==&amp;gt; 依次运行当前package的 _test.</description>
    </item>
    
    <item>
      <title>使用docker运行mysql</title>
      <link>https://limingxie.github.io/limingxie/docker_mysql/</link>
      <pubDate>Tue, 27 Mar 2018 07:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/limingxie/docker_mysql/</guid>
      <description>以前开发的时候都是用本地的sqlite开发，但是极少数情况下，sqlite支持的语法发布到服务器上链接mysql会报错。
为了避免这种现象，还是链接本地mysql开发还是更稳定的， 可是开发的项目多了后，本地的mysql库看起来好乱。 而且有很多项目是实验性的项目，没有及时处理的话会产生很多垃圾数据。
要不使用docker运行mysql，开发结束后把容器删掉 ?  前提是需要准备测试数据脚本，开发或测试的时候随时可以删除，添加数据。 这样就不会因为删除docker容器，重新添加数据而烦恼。 做测试数据很麻烦~ 但是写测试代码，这些测试数据脚本也是必要的。  废话有点多了，说说如何去做。来点干货&amp;hellip;^^
1. 安装docker (建议上官网下载安装包安装。)
$ brew install docker  2. 下载mysql镜像
$ docker pull mysql  3. 启动mysql实例
$ docker run --name mingxie-mysql -p 32xxx:3306 -e MYSQL_ROOT_PASSWORD=1234 -d mysql:latest   &amp;mdash;name 后面的是docker容器名 -p 32xxx:3306 这里需要注意 32xxx 是你链接mysql的时候的Port。 -e MYSQL_ROOT_PASSWORD 是设置mysql的root账号密码 -d mysql 是你的镜像标签  4. 在shell中访问mysql
docker exec -it mingxie-mysql bash root@7c289aa0ca95:/# mysql -uroot -p -h localhost Enter password:  输入密码即可。</description>
    </item>
    
    <item>
      <title>用hugo搭建个人博客</title>
      <link>https://limingxie.github.io/limingxie/hugo_create/</link>
      <pubDate>Wed, 14 Mar 2018 10:14:08 +0800</pubDate>
      
      <guid>https://limingxie.github.io/limingxie/hugo_create/</guid>
      <description>这几天研究了用hugo搭建个人博客。
简单的整理了一下。
1.安装hugo（windows 请查看官网介绍 https://gohugo.io/getting-started/installing/）
$ brew install hugo  之后检查版本
$ hugo version Hugo Static Site Generator v0.37.1 darwin/amd64 BuildDate:  2.创建hugo 项目
$ hugo new site my-blog Congratulations! Your new Hugo site is created in /Users/limingxie/Projects/my-blog. Just a few more steps and you&#39;re ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/, or create your own with the &amp;quot;hugo new theme &amp;lt;THEMENAME&amp;gt;&amp;quot; command.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://limingxie.github.io/java/encapsulation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://limingxie.github.io/java/encapsulation/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://limingxie.github.io/java/inheritance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://limingxie.github.io/java/inheritance/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://limingxie.github.io/java/polymorphism/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://limingxie.github.io/java/polymorphism/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
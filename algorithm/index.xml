<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithms on li_mingxie - Blog</title>
    <link>https://limingxie.github.io/algorithm/</link>
    <description>Recent content in Algorithms on li_mingxie - Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>limingxie - blog</copyright>
    <lastBuildDate>Sat, 03 Aug 2019 07:28:49 +0800</lastBuildDate>
    
	<atom:link href="https://limingxie.github.io/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>递归(recursive)</title>
      <link>https://limingxie.github.io/algorithm/recursive/</link>
      <pubDate>Sat, 03 Aug 2019 07:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/algorithm/recursive/</guid>
      <description>最近在研究算法&amp;hellip;^^ 算法中最基本的是排序。
排序当中最常见的是快速排序(Quick Sort)。
理解快速排序的代码，那就离不开递归了。
递归以前听过，但是真正去了解和研究是最近为了对算法的了解。
 递归感觉很绕？
 但是理解其原理的话还是可以接受的，甚至有时候会喜欢这种方式。
 递归不像传说中的那么麻烦。弄清楚
基线条件（base case）和 递归条件（recursive case）
 绝大多数的递归都是这种结构
function(parameter){ if 基线条件（base case）{ //离开递归的条件，这条件如果不明确，或是满足不了。很容易进入死循环。 return } XXXX...XXXX //处理业务逻辑 if 递归条件（recursive case）{ //进入递归的条件 function(parameter) } }  来看看一个简单的例子吧。详细内容可以看这里
https://pintia.cn/problem-sets/994805260223102976/problems/994805325918486528
卡拉兹(Callatz)猜想： 对任何一个正整数 n，如果它是偶数，那么把它砍掉一半； 如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。 我们假设 n &amp;lt; 1000 输入样例： 3 输出样例： 5  一般情况下我们是直接用while或for循环处理。
#include &amp;lt;stdio.h&amp;gt; int main() { int step = 0; //记录步数 int n = 0; scanf(&amp;quot;%d&amp;quot;, &amp;amp;n); while (n !</description>
    </item>
    
    <item>
      <title>算法(排序)</title>
      <link>https://limingxie.github.io/algorithm/sort/</link>
      <pubDate>Tue, 09 Jul 2019 07:28:49 +0800</pubDate>
      
      <guid>https://limingxie.github.io/algorithm/sort/</guid>
      <description>感觉现在越来越重视算法了。
因为我不是计算机专业的，所以对这些算法没怎么注意过。
这么高领的程序员居然才接触到这些算法，真是惭愧啊&amp;hellip;^^;;
以下代码都是用golang写的，算是给自己看的笔记~
(1) 冒泡排序(Bubble Sort) (2) 选择排序(Selection Sort) (3) 插入排序(Insertion Sort) (4) 希尔排序(Shell Sort) (5) 归并排序(Merge Sort) (6) 快速排序(Quick Sort) (7) 基数排序(Radix Sort) (8) 堆排序(Heap Sort)   ◆ 冒泡排序(Bubble Sort)
图片备用地址
//泡沫排序 func BubbleSort() { data := []int{8, 100, 99, 50, 22, 15, 16, 2, 99, 1000, 999, 1} for i := 0; i &amp;lt; len(data); i++ { for j := 0; j &amp;lt; len(data)-i; j++ { if data[j] &amp;gt; data[j+1] { v := data[j] data[j] = data[j+1] data[j+1] = v } } } fmt.</description>
    </item>
    
  </channel>
</rss>